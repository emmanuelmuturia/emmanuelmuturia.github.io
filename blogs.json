{"status":"ok","feed":{"url":"https://medium.com/feed/@emmanuelmuturia","title":"Stories by Emmanuel Muturia\u2122 on Medium","link":"https://medium.com/@emmanuelmuturia?source=rss-6256c7dbb031------2","author":"","description":"Stories by Emmanuel Muturia\u2122 on Medium","image":"https://cdn-images-1.medium.com/fit/c/150/150/1*0E7RbCX7mUb7xgkG79A5jQ.png"},"items":[{"title":"How To Fix The \u201c{\u201cmessage\u201d:\u201dInternal Server Error\u201d}\u201d Error in AWS","pubDate":"2025-05-29 15:39:26","link":"https://medium.com/@emmanuelmuturia/how-to-fix-the-message-internal-server-error-error-in-aws-9e8716c6972a?source=rss-6256c7dbb031------2","guid":"https://medium.com/p/9e8716c6972a","author":"Emmanuel Muturia\u2122","thumbnail":"","description":"\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*BIW3OIJ2dpPUbRUYCVlEHA.png\"></figure><p>You are well on your way to provisioning your AWS Infrastructure. Perhaps like me, you are setting up the Backend of that soon-to-be-viral Mobile App of yours, or maybe you are a Master Backend Engineer who spins Backends to life by whistling some commands to your workstation. Regardless of your use case, chances are you ran into an error message that left you wondering what part of your humongous Infrastructure was misbehaving. I mean, let us face it. Unless you are a Solutions Architect or similar, chances are you have not mastered the tip of the iceberg when it comes to the services offered by AWS. What error message am I referring to, though? Ladies and gentlemen, I present to\u00a0you:</p>\n<pre>{\"message\":\"Internal Server Error\"}</pre>\n<h3>THE BACKGROUND</h3>\n<p>I was working on a project [to be shared soon with you guys], and part of it consisted of deploying a REST API [AWS API Gateway] using AWS Lambda. At first, everything was working smoothly, and I had encountered no errors. \u201cSomething is not right\u2026\u201d, I thought. Of course, any regular individual will wonder what was up with my pessimism. However, I know that you, a Techie, understand why I was not confident in the smooth flow of events. True to my suspicions, that error message slapped me just as I was about to deploy my Infrastructure, or at least a portion of it. Talk about timing, right? Anyway, I kept receiving that error and due to its ambiguity, I had trouble working out why it was re-occurring despite my Infrastructure\u2019s configuration looking like it was rightly set up. That was where my troubleshooting session began, and what I found made me laugh as if it had made fun of me, which I guess it did. Now, let me take you through how I diagnosed the issue and what it led me to, so that you can hopefully experience the\u00a0same\u2026</p>\n<h3>THE DIAGNOSIS</h3>\n<h4><strong>STEP 1] THE INFRASTRUCTURE CONFIGURATION</strong></h4>\n<p>Of course, my first step was to double-check my Infrastructure\u2019s configuration. As I was using Terraform to provision my Infrastructure, I checked my\u00a0.tf files for any misconfigurations. In your case, this could mean double-checking your configuration on the AWS Console or whatever resources you are currently using to set up your AWS Infrastructure. Trust me, most errors of this nature originate from\u00a0here\u2026</p>\n<h4><strong>STEP 2] THE\u00a0LOGS</strong></h4>\n<p>As expected, my next step was to check my Logs, specifically CloudWatch Logs. The easiest way to do this is by navigating to <strong>CloudWatch &gt; Log Groups</strong>. From here, I selected the Log Group that was tied to my Infrastructure. For you, this shouldshed more light on what the issue could\u00a0be\u2026</p>\n<p><strong>Spoiler Alert:</strong> This led me to the solution\u2026</p>\n<h4><strong>STEP 3] THE LAMBDA\u00a0TEST</strong></h4>\n<p>At this point, the CloudWatch Logs were not helpful as I had yet to update them to match my real-time REST API Requests. My next best option was to navigate to <strong>AWS Lambda </strong>and test the Lambda Function manually to see what the issue is. Oh, in case I did not mention, I was essentially using a Lambda Function to make a REST API Call to my AWS Infrastructure. Again, your use case could be different, but this is usually the most common one that results in the error message that this article focuses on. Now, what happened\u00a0here?</p>\n<p>Well, I tested the Lambda Function, and as expected, it failed massively. Alright, maybe that is an overstatement, but it did fail. The reason was rather silly, and I do not want you to click off, so let me spare you the details. It was a file path referencing issue. Can you believe that? I know. How surprising. This was not the end of the story,\u00a0though\u2026</p>\n<p>I tested the Lambda Function again, and it still threw the error. This time, the Logs were different. I can already sense your excitement, and yes, I too experienced it. This is what I\u00a0got:</p>\n<pre>[More Logs here...]<br>\"errorType\": \"AuthorizationErrorException\"<br>[More Logs here too...]</pre>\n<p>You already know where this is headed, so let me cut right to the chase. It turned out that I did not assign my Lambda Function the right permissions to make that REST API Call. This was the culprit all\u00a0along\u2026</p>\n<p>[This is where I laughed at myself, by the\u00a0way\u2026]</p>\n<h3><strong>WHAT SHOULD YOU TAKE AWAY FROM\u00a0THIS?</strong></h3>\n<ul>\n<li>Please read on, understand, and practise IAM and IAM Policies in\u00a0AWS\u2026</li>\n<li>When provisioning your AWS Infrastructure, always double-check if each component has been assigned the right permissions for its task. If you are in Cyber Security, you might recognise a similar concept known as <strong>The Principle of Least Privilege</strong>\u2026</li>\n<li>Again, please read more on IAM in AWS. I do not know why it had to be made this difficult to understand, at least in the beginning, alright? Just read and understand it, and you should be good to go. I\u00a0hope\u2026</li>\n</ul>\n<h3><strong>CONCLUSION</strong></h3>\n<p>By this point, you now understand the common pitfalls that contribute to the dreaded [well, not so much] \u201cServer Error\u201d error when setting up an AWS Infrastructure. If this has not solved your error, then read it again. If it still does not fix your error, then just quit and use another Cloud provider. There are plenty of fish in the sea. I am kidding, though. If your error persists, then I highly recommend that you revisit your AWS Infrastructure and revise your components before testing them on the console while monitoring the logs. Alright, it is time for me to go back to building, and I hope to share with you what I am working\u00a0on\u2026</p>\n<p>What error made you laugh at yourself like I did before publishing this\u00a0article?</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=9e8716c6972a\" width=\"1\" height=\"1\" alt=\"\">\n","content":"\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*BIW3OIJ2dpPUbRUYCVlEHA.png\"></figure><p>You are well on your way to provisioning your AWS Infrastructure. Perhaps like me, you are setting up the Backend of that soon-to-be-viral Mobile App of yours, or maybe you are a Master Backend Engineer who spins Backends to life by whistling some commands to your workstation. Regardless of your use case, chances are you ran into an error message that left you wondering what part of your humongous Infrastructure was misbehaving. I mean, let us face it. Unless you are a Solutions Architect or similar, chances are you have not mastered the tip of the iceberg when it comes to the services offered by AWS. What error message am I referring to, though? Ladies and gentlemen, I present to\u00a0you:</p>\n<pre>{\"message\":\"Internal Server Error\"}</pre>\n<h3>THE BACKGROUND</h3>\n<p>I was working on a project [to be shared soon with you guys], and part of it consisted of deploying a REST API [AWS API Gateway] using AWS Lambda. At first, everything was working smoothly, and I had encountered no errors. \u201cSomething is not right\u2026\u201d, I thought. Of course, any regular individual will wonder what was up with my pessimism. However, I know that you, a Techie, understand why I was not confident in the smooth flow of events. True to my suspicions, that error message slapped me just as I was about to deploy my Infrastructure, or at least a portion of it. Talk about timing, right? Anyway, I kept receiving that error and due to its ambiguity, I had trouble working out why it was re-occurring despite my Infrastructure\u2019s configuration looking like it was rightly set up. That was where my troubleshooting session began, and what I found made me laugh as if it had made fun of me, which I guess it did. Now, let me take you through how I diagnosed the issue and what it led me to, so that you can hopefully experience the\u00a0same\u2026</p>\n<h3>THE DIAGNOSIS</h3>\n<h4><strong>STEP 1] THE INFRASTRUCTURE CONFIGURATION</strong></h4>\n<p>Of course, my first step was to double-check my Infrastructure\u2019s configuration. As I was using Terraform to provision my Infrastructure, I checked my\u00a0.tf files for any misconfigurations. In your case, this could mean double-checking your configuration on the AWS Console or whatever resources you are currently using to set up your AWS Infrastructure. Trust me, most errors of this nature originate from\u00a0here\u2026</p>\n<h4><strong>STEP 2] THE\u00a0LOGS</strong></h4>\n<p>As expected, my next step was to check my Logs, specifically CloudWatch Logs. The easiest way to do this is by navigating to <strong>CloudWatch &gt; Log Groups</strong>. From here, I selected the Log Group that was tied to my Infrastructure. For you, this shouldshed more light on what the issue could\u00a0be\u2026</p>\n<p><strong>Spoiler Alert:</strong> This led me to the solution\u2026</p>\n<h4><strong>STEP 3] THE LAMBDA\u00a0TEST</strong></h4>\n<p>At this point, the CloudWatch Logs were not helpful as I had yet to update them to match my real-time REST API Requests. My next best option was to navigate to <strong>AWS Lambda </strong>and test the Lambda Function manually to see what the issue is. Oh, in case I did not mention, I was essentially using a Lambda Function to make a REST API Call to my AWS Infrastructure. Again, your use case could be different, but this is usually the most common one that results in the error message that this article focuses on. Now, what happened\u00a0here?</p>\n<p>Well, I tested the Lambda Function, and as expected, it failed massively. Alright, maybe that is an overstatement, but it did fail. The reason was rather silly, and I do not want you to click off, so let me spare you the details. It was a file path referencing issue. Can you believe that? I know. How surprising. This was not the end of the story,\u00a0though\u2026</p>\n<p>I tested the Lambda Function again, and it still threw the error. This time, the Logs were different. I can already sense your excitement, and yes, I too experienced it. This is what I\u00a0got:</p>\n<pre>[More Logs here...]<br>\"errorType\": \"AuthorizationErrorException\"<br>[More Logs here too...]</pre>\n<p>You already know where this is headed, so let me cut right to the chase. It turned out that I did not assign my Lambda Function the right permissions to make that REST API Call. This was the culprit all\u00a0along\u2026</p>\n<p>[This is where I laughed at myself, by the\u00a0way\u2026]</p>\n<h3><strong>WHAT SHOULD YOU TAKE AWAY FROM\u00a0THIS?</strong></h3>\n<ul>\n<li>Please read on, understand, and practise IAM and IAM Policies in\u00a0AWS\u2026</li>\n<li>When provisioning your AWS Infrastructure, always double-check if each component has been assigned the right permissions for its task. If you are in Cyber Security, you might recognise a similar concept known as <strong>The Principle of Least Privilege</strong>\u2026</li>\n<li>Again, please read more on IAM in AWS. I do not know why it had to be made this difficult to understand, at least in the beginning, alright? Just read and understand it, and you should be good to go. I\u00a0hope\u2026</li>\n</ul>\n<h3><strong>CONCLUSION</strong></h3>\n<p>By this point, you now understand the common pitfalls that contribute to the dreaded [well, not so much] \u201cServer Error\u201d error when setting up an AWS Infrastructure. If this has not solved your error, then read it again. If it still does not fix your error, then just quit and use another Cloud provider. There are plenty of fish in the sea. I am kidding, though. If your error persists, then I highly recommend that you revisit your AWS Infrastructure and revise your components before testing them on the console while monitoring the logs. Alright, it is time for me to go back to building, and I hope to share with you what I am working\u00a0on\u2026</p>\n<p>What error made you laugh at yourself like I did before publishing this\u00a0article?</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=9e8716c6972a\" width=\"1\" height=\"1\" alt=\"\">\n","enclosure":{},"categories":["cloud-security","aws","cloud","aws-lambda","cybersecurity"]},{"title":"The Android Architecture [feat. The System Apps]","pubDate":"2025-04-01 04:02:12","link":"https://medium.com/@emmanuelmuturia/97413b19dca1?source=rss-6256c7dbb031------2","guid":"https://medium.com/p/97413b19dca1","author":"Emmanuel Muturia\u2122","thumbnail":"","description":"\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/606/1*D76xDIBCcxvjpJ1giZxkQQ.png\"></figure><p>You have made it, dear reader. You may applaud yourself now. After traversing the technicalities of The Android Architecture, it is now time to talk about the good stuff. Well, the ones that kinda involve us who love to build Android apps and stuff. This article concludes this series by talking about <strong>The System Apps</strong>. As they say, \u201cSave the best for last\u2026\u201d. I am not sure if it is \u201cthey\u201d who said it but I believe it\u00a0anyway\u2026</p>\n<h3>1. Overview: What Are System\u00a0Apps?</h3>\n<p>System apps are the pre-installed applications that come with the Android operating system. They form the core suite of software essential for device functionality, ranging from the phone dialer, contacts, and messaging to core services like settings, system UI, and more. Developed by the OEMs or the Android Open Source Project (AOSP), these apps run with elevated privileges, have direct integration with the OS, and provide a consistent, secure, and optimized user experience. They are critical for booting the device, managing hardware interactions, and offering fundamental services that third-party apps cannot replicate\u2026</p>\n<p><strong>Analogy</strong><br>Think of system apps as the essential features built into a car by the manufacturer\u200a\u2014\u200alike the dashboard instruments, the steering system, braking controls, and integrated safety features. These components are not optional add-ons; they are built into the car\u2019s design to ensure safety, reliability, and a seamless driving experience, much like system apps are integral to the Android experience\u2026</p>\n<h3>2. Core Functions and Essential Services</h3>\n<p>System apps provide the backbone of daily operations on an Android device. They include core functionalities such as telephony services, contact management, messaging, camera functionality, and system settings. Beyond these, they often include system-level utilities like file managers, network configuration tools, and update managers. Their design is tightly coupled with system APIs, ensuring high reliability and optimal performance even under demanding conditions\u2026</p>\n<p><strong>Analogy</strong><br>Imagine a car equipped with all the built-in systems necessary for daily operation: the Engine Control Unit [ECU] that manages engine performance, integrated infotainment for navigation and communication, and safety systems like airbags and ABS. Just as these built-in features ensure the car functions seamlessly from the moment you start it, system apps ensure that your Android device is fully operational and optimized for everyday\u00a0tasks\u2026</p>\n<h3>3. Privileges, Security, and\u00a0Trust</h3>\n<p>System apps operate with a higher level of privilege compared to third-party applications. They can access secure system resources, interact with hardware at a low level, and execute critical system commands. This elevated trust level is managed through stringent security policies and digital signatures. The framework ensures that these apps are vetted, maintained, and updated by trusted sources to protect against vulnerabilities and unauthorised access, thereby safeguarding the overall system integrity\u2026</p>\n<p><strong>Analogy</strong><br>Consider these apps as the factory-installed security features in a car\u200a\u2014\u200asuch as the anti-theft system, advanced braking controls, and stability management systems. Just as these components are rigorously tested and certified to protect the driver, system apps run with heightened privileges and robust security measures to protect the device and ensure reliable operation\u2026</p>\n<h3>4. Integration with the Operating System and\u00a0Hardware</h3>\n<p>System apps are deeply integrated with the Android operating system. They work in tandem with core system services, the Hardware Abstraction Layer [HAL], and other native components to deliver seamless functionality. This integration allows them to leverage low-level hardware capabilities, respond to system-wide events, and interact directly with other system components. Their close coupling with the OS facilitates rapid updates and tight coordination during system boot, runtime configuration, and even shutdown procedures\u2026</p>\n<p><strong>Analogy</strong><br>Think of system apps as the car\u2019s integrated control systems that work hand-in-hand with the vehicle\u2019s mechanics. For instance, the car\u2019s ABS works closely with sensors, the braking system, and the ECU to provide optimal stopping power. Similarly, system apps integrate with Android\u2019s core services and hardware interfaces to deliver a smooth, coordinated performance throughout the device\u2019s lifecycle\u2026</p>\n<h3>5. Performance, Resource Management, and Optimization</h3>\n<p>System apps are optimised for performance and efficient resource management. They are built to handle high loads and execute critical functions with minimal latency. Developers use extensive profiling, real-time debugging, and hardware-specific optimizations to ensure these apps consume fewer resources while delivering robust performance. Their code is often tightly optimised to balance power consumption, responsiveness, and system stability, which is crucial in resource-constrained mobile environments\u2026</p>\n<p><strong>Analogy</strong><br>Imagine a finely tuned car where every component is optimised for maximum performance and fuel efficiency\u200a\u2014\u200afrom the engine\u2019s high-compression design to aerodynamic bodywork. The car\u2019s systems are calibrated to reduce friction, minimize energy loss, and deliver peak performance under various driving conditions. In the same way, system apps are engineered to run swiftly, manage resources effectively, and keep the device operating at its\u00a0best\u2026</p>\n<h3>6. Update Mechanisms and System Integrity</h3>\n<p>System apps are subject to strict update protocols to ensure that the device remains secure, stable, and feature-rich. Updates are typically delivered via Over-The-Air [OTA] system updates or through pre-approved channels from the device manufacturer. These updates often include security patches, performance enhancements, and new features, and they undergo rigorous testing to maintain system integrity. The centralised management of these apps allows for consistent updates across the entire device ecosystem, ensuring that all critical services are current and\u00a0secure\u2026</p>\n<p><strong>Analogy</strong><br>Think of this process as the periodic service and software updates that modern cars receive\u200a\u2014\u200aupdates to the onboard computer, firmware upgrades for safety systems, and recalls for critical components. Just as these updates keep the car safe, reliable, and up-to-date with the latest technology, system app updates ensure that your Android device remains secure and efficient, maintaining a high standard of performance over its lifetime\u2026</p>\n<h3>7. Evolution, Customisation, and Future\u00a0Trends</h3>\n<p>The landscape of system apps is continually evolving as Android grows and adapts to new technological trends. Innovations such as machine learning, augmented reality, and advanced connectivity are increasingly being integrated into system-level functionalities. Future system apps are expected to incorporate more adaptive user interfaces, context-aware services, and predictive features that enhance usability and efficiency. Customisation is also becoming more prominent, allowing OEMs to tailor system apps to differentiate their devices while still adhering to core Android standards. This dynamic evolution ensures that system apps remain at the forefront of mobile technology, driving innovation and enhancing the overall user experience\u2026</p>\n<p><strong>Analogy</strong><br>Consider the evolution of automotive technology\u200a\u2014\u200afrom classic mechanical instruments to digital dashboards, autonomous driving features, and smart connectivity. As cars integrate more advanced systems, they become not only safer and more efficient but also increasingly personalized to the driver\u2019s preferences. Likewise, the evolution of system apps promises a future where your device is more intelligent, adaptable, and seamlessly integrated with emerging technologies, delivering an ever-improving driving [User] experience.</p>\n<h3>CONCLUSION</h3>\n<p>Apart from the desire to drive your Car right now, I hope that you have now gotten a better and more technical understanding of The System Apps in the context [pun intended] of The Android Architecture. While this may be the end of this series whose name I still do not know, please stay tuned for more content so that we can learn together, right? Until then, I hope that you remember what you learned today each time you work on your\u00a0car[s]\u2026</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/498/0*IcGouFB37jkyhMqF.gif\"></figure><h3>REFERENCES</h3>\n<p><em>Platform Architecture</em>. (2023, May 4). Android Developers. <a href=\"https://developer.android.com/guide/platform\">https://developer.android.com/guide/platform</a></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=97413b19dca1\" width=\"1\" height=\"1\" alt=\"\">\n","content":"\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/606/1*D76xDIBCcxvjpJ1giZxkQQ.png\"></figure><p>You have made it, dear reader. You may applaud yourself now. After traversing the technicalities of The Android Architecture, it is now time to talk about the good stuff. Well, the ones that kinda involve us who love to build Android apps and stuff. This article concludes this series by talking about <strong>The System Apps</strong>. As they say, \u201cSave the best for last\u2026\u201d. I am not sure if it is \u201cthey\u201d who said it but I believe it\u00a0anyway\u2026</p>\n<h3>1. Overview: What Are System\u00a0Apps?</h3>\n<p>System apps are the pre-installed applications that come with the Android operating system. They form the core suite of software essential for device functionality, ranging from the phone dialer, contacts, and messaging to core services like settings, system UI, and more. Developed by the OEMs or the Android Open Source Project (AOSP), these apps run with elevated privileges, have direct integration with the OS, and provide a consistent, secure, and optimized user experience. They are critical for booting the device, managing hardware interactions, and offering fundamental services that third-party apps cannot replicate\u2026</p>\n<p><strong>Analogy</strong><br>Think of system apps as the essential features built into a car by the manufacturer\u200a\u2014\u200alike the dashboard instruments, the steering system, braking controls, and integrated safety features. These components are not optional add-ons; they are built into the car\u2019s design to ensure safety, reliability, and a seamless driving experience, much like system apps are integral to the Android experience\u2026</p>\n<h3>2. Core Functions and Essential Services</h3>\n<p>System apps provide the backbone of daily operations on an Android device. They include core functionalities such as telephony services, contact management, messaging, camera functionality, and system settings. Beyond these, they often include system-level utilities like file managers, network configuration tools, and update managers. Their design is tightly coupled with system APIs, ensuring high reliability and optimal performance even under demanding conditions\u2026</p>\n<p><strong>Analogy</strong><br>Imagine a car equipped with all the built-in systems necessary for daily operation: the Engine Control Unit [ECU] that manages engine performance, integrated infotainment for navigation and communication, and safety systems like airbags and ABS. Just as these built-in features ensure the car functions seamlessly from the moment you start it, system apps ensure that your Android device is fully operational and optimized for everyday\u00a0tasks\u2026</p>\n<h3>3. Privileges, Security, and\u00a0Trust</h3>\n<p>System apps operate with a higher level of privilege compared to third-party applications. They can access secure system resources, interact with hardware at a low level, and execute critical system commands. This elevated trust level is managed through stringent security policies and digital signatures. The framework ensures that these apps are vetted, maintained, and updated by trusted sources to protect against vulnerabilities and unauthorised access, thereby safeguarding the overall system integrity\u2026</p>\n<p><strong>Analogy</strong><br>Consider these apps as the factory-installed security features in a car\u200a\u2014\u200asuch as the anti-theft system, advanced braking controls, and stability management systems. Just as these components are rigorously tested and certified to protect the driver, system apps run with heightened privileges and robust security measures to protect the device and ensure reliable operation\u2026</p>\n<h3>4. Integration with the Operating System and\u00a0Hardware</h3>\n<p>System apps are deeply integrated with the Android operating system. They work in tandem with core system services, the Hardware Abstraction Layer [HAL], and other native components to deliver seamless functionality. This integration allows them to leverage low-level hardware capabilities, respond to system-wide events, and interact directly with other system components. Their close coupling with the OS facilitates rapid updates and tight coordination during system boot, runtime configuration, and even shutdown procedures\u2026</p>\n<p><strong>Analogy</strong><br>Think of system apps as the car\u2019s integrated control systems that work hand-in-hand with the vehicle\u2019s mechanics. For instance, the car\u2019s ABS works closely with sensors, the braking system, and the ECU to provide optimal stopping power. Similarly, system apps integrate with Android\u2019s core services and hardware interfaces to deliver a smooth, coordinated performance throughout the device\u2019s lifecycle\u2026</p>\n<h3>5. Performance, Resource Management, and Optimization</h3>\n<p>System apps are optimised for performance and efficient resource management. They are built to handle high loads and execute critical functions with minimal latency. Developers use extensive profiling, real-time debugging, and hardware-specific optimizations to ensure these apps consume fewer resources while delivering robust performance. Their code is often tightly optimised to balance power consumption, responsiveness, and system stability, which is crucial in resource-constrained mobile environments\u2026</p>\n<p><strong>Analogy</strong><br>Imagine a finely tuned car where every component is optimised for maximum performance and fuel efficiency\u200a\u2014\u200afrom the engine\u2019s high-compression design to aerodynamic bodywork. The car\u2019s systems are calibrated to reduce friction, minimize energy loss, and deliver peak performance under various driving conditions. In the same way, system apps are engineered to run swiftly, manage resources effectively, and keep the device operating at its\u00a0best\u2026</p>\n<h3>6. Update Mechanisms and System Integrity</h3>\n<p>System apps are subject to strict update protocols to ensure that the device remains secure, stable, and feature-rich. Updates are typically delivered via Over-The-Air [OTA] system updates or through pre-approved channels from the device manufacturer. These updates often include security patches, performance enhancements, and new features, and they undergo rigorous testing to maintain system integrity. The centralised management of these apps allows for consistent updates across the entire device ecosystem, ensuring that all critical services are current and\u00a0secure\u2026</p>\n<p><strong>Analogy</strong><br>Think of this process as the periodic service and software updates that modern cars receive\u200a\u2014\u200aupdates to the onboard computer, firmware upgrades for safety systems, and recalls for critical components. Just as these updates keep the car safe, reliable, and up-to-date with the latest technology, system app updates ensure that your Android device remains secure and efficient, maintaining a high standard of performance over its lifetime\u2026</p>\n<h3>7. Evolution, Customisation, and Future\u00a0Trends</h3>\n<p>The landscape of system apps is continually evolving as Android grows and adapts to new technological trends. Innovations such as machine learning, augmented reality, and advanced connectivity are increasingly being integrated into system-level functionalities. Future system apps are expected to incorporate more adaptive user interfaces, context-aware services, and predictive features that enhance usability and efficiency. Customisation is also becoming more prominent, allowing OEMs to tailor system apps to differentiate their devices while still adhering to core Android standards. This dynamic evolution ensures that system apps remain at the forefront of mobile technology, driving innovation and enhancing the overall user experience\u2026</p>\n<p><strong>Analogy</strong><br>Consider the evolution of automotive technology\u200a\u2014\u200afrom classic mechanical instruments to digital dashboards, autonomous driving features, and smart connectivity. As cars integrate more advanced systems, they become not only safer and more efficient but also increasingly personalized to the driver\u2019s preferences. Likewise, the evolution of system apps promises a future where your device is more intelligent, adaptable, and seamlessly integrated with emerging technologies, delivering an ever-improving driving [User] experience.</p>\n<h3>CONCLUSION</h3>\n<p>Apart from the desire to drive your Car right now, I hope that you have now gotten a better and more technical understanding of The System Apps in the context [pun intended] of The Android Architecture. While this may be the end of this series whose name I still do not know, please stay tuned for more content so that we can learn together, right? Until then, I hope that you remember what you learned today each time you work on your\u00a0car[s]\u2026</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/498/0*IcGouFB37jkyhMqF.gif\"></figure><h3>REFERENCES</h3>\n<p><em>Platform Architecture</em>. (2023, May 4). Android Developers. <a href=\"https://developer.android.com/guide/platform\">https://developer.android.com/guide/platform</a></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=97413b19dca1\" width=\"1\" height=\"1\" alt=\"\">\n","enclosure":{},"categories":["androiddev","android","android-app-developers","android-app-development","android-apps"]},{"title":"The Android Architecture [feat. The J*va API Framework]","pubDate":"2025-03-25 04:02:41","link":"https://medium.com/@emmanuelmuturia/74fb865f6431?source=rss-6256c7dbb031------2","guid":"https://medium.com/p/74fb865f6431","author":"Emmanuel Muturia\u2122","thumbnail":"","description":"\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/617/1*igYWo-4_kiuMXGpwPk1OTw.png\"></figure><p>Well done, dear reader. You are more than halfway there. Before you applaud yourself, though, I need to warn you about this article. While I value the impact of the layer that will be discussed today, you need to be wary of the technology behind it. Rumour has it that it was almost rendered obsolete in the world of Android once its successor took over since the year 2017. Yes. That is what we are dealing with today. Anyway, this article talks about the different APIs that are responsible for the rich features of Android and how they work together to bring Android apps [both Developer Apps and System Apps] to life. Today, we will be talking about <strong>The J*va API Framework</strong>\u2026</p>\n<h3>1. Overview: What Is the J*va API Framework?</h3>\n<p>The J*va API Framework is the cornerstone of Android application development. It is a vast collection of classes, interfaces, and libraries built primarily on J*va (and increasingly Kotlin) that developers use to build applications. This framework provides everything from UI components and system services to networking, data management, and more. It abstracts complex underlying system operations and offers a standardized set of tools that ensure apps can interact consistently with the Android operating system across different devices\u2026</p>\n<p><strong>Analogy</strong><br>Think of the J*va API Framework as the car\u2019s dashboard and control center. Just as a driver uses the dashboard to monitor speed, fuel, and engine status without needing to understand the intricacies of the engine, developers use the API to control and interact with the device\u2019s functionalities without diving into low-level system\u00a0details\u2026</p>\n<h3>2. Core Components: Standard Libraries and Essential Services</h3>\n<p>At its heart, the framework comprises a collection of core libraries and packages\u200a\u2014\u200asuch as java.lang, java.util, and Android-specific packages like android.app, android.content, android.view, and more. These libraries provide fundamental services including event handling, resource management, layout rendering, and connectivity. They serve as modular building blocks that facilitate the rapid development of robust applications by providing pre-built, well-tested functionality\u2026</p>\n<p><strong>Analogy</strong><br>Imagine these core libraries as the standard components found in every modern car\u200a\u2014\u200alike the engine, transmission, braking system, and infotainment controls. These parts are designed to work seamlessly together, giving you a reliable and familiar experience regardless of the car\u2019s brand, much like how the Java API Framework provides a consistent set of tools for app development\u2026</p>\n<h3>3. Application Components and Architecture</h3>\n<p>The framework defines the structure and lifecycle of key Android application components such as Activities, Services, BroadcastReceivers, and Content Providers. These components dictate how apps manage user interactions, background processes, and data exchange. The framework enforces architectural patterns [e.g., MVC, MVP, MVVM] to ensure that apps are scalable, maintainable, and responsive. It also governs the flow of information and control among these components to provide a coherent and integrated user experience\u2026</p>\n<p><strong>Analogy</strong><br>Consider these application components as the different subsystems of a car. An Activity is like the car\u2019s main driving mode, Services resemble the background systems such as climate control or navigation, BroadcastReceivers act like the car\u2019s warning lights that alert you to changes, and Content Providers are akin to the car\u2019s storage compartments that organize your gear. Together, they form a well-orchestrated system that delivers a smooth and reliable driving experience\u2026</p>\n<h3>4. Abstraction and Ease-of-Use: Simplifying Complexity</h3>\n<p>One of the primary strengths of the Java API Framework is its ability to abstract complex operations into simple, high-level interfaces. This abstraction hides the intricate details of hardware management, network protocols, and system security from developers. Instead of writing low-level code, developers can invoke straightforward methods to perform complex tasks such as drawing graphics, handling user input, or accessing remote data. This approach not only accelerates development but also reduces the likelihood of\u00a0errors\u2026</p>\n<p><strong>Analogy</strong><br>Think of this abstraction as the car\u2019s steering wheel and pedals. You don\u2019t need to understand the combustion process or the intricacies of the suspension system to steer, accelerate, or brake. The intuitive controls simplify the driving process, just as the J*va API Framework simplifies app development by hiding complex system internals behind user-friendly interfaces\u2026</p>\n<h3>5. Consistency and Integration: A Unified Development Experience</h3>\n<p>The Java API Framework ensures that all Android applications have a consistent behavior across diverse hardware and software configurations. It integrates seamlessly with other critical layers of the Android ecosystem, such as the Android Runtime (ART), the Hardware Abstraction Layer (HAL), and native libraries. This integration allows developers to build applications that can leverage system resources efficiently, adhere to best practices for security and performance, and provide a uniform user experience regardless of the underlying device architecture\u2026</p>\n<p><strong>Analogy</strong><br>Imagine driving on a highway where every vehicle, regardless of its make or model, follows the same road rules and uses standardized road signs. The consistent framework acts like this standardized system, ensuring that every \u201cdriver\u201d (app) interacts predictably with the \u201croad\u201d (device), leading to a smooth and harmonious journey for everyone\u2026</p>\n<h3>6. Development Tools and Ecosystem Support</h3>\n<p>The Java API Framework is supported by a robust ecosystem of development tools and environments\u200a\u2014\u200amost notably Android Studio. These tools offer features like code autocompletion, real-time debugging, profiling, and extensive documentation that streamline the development process. They empower developers to design, test, and refine their applications with efficiency and precision. Additionally, comprehensive API documentation and community resources help troubleshoot issues and encourage best practices across the developer community\u2026</p>\n<p><strong>Analogy</strong><br>Think of these development tools as the car\u2019s Onboard Diagnostics System [OBD] and navigation aids. Just as these systems help you monitor your car\u2019s health, troubleshoot issues, and plan the best routes, the ecosystem surrounding the Java API Framework guides developers through building high-quality applications by providing real-time feedback, suggestions, and a wealth of information to keep the \u201cvehicle\u201d of your app in top\u00a0shape\u2026</p>\n<h3>7. Evolution and Future Trends: Driving Innovation Forward</h3>\n<p>The J*va API Framework is continuously evolving to meet the demands of modern application development. It adapts to new programming paradigms such as reactive programming and functional interfaces, and it integrates smoothly with newer languages like Kotlin. Ongoing improvements in performance, security, and developer ergonomics ensure that the framework remains at the cutting edge of mobile technology. This evolution enables developers to build innovative applications that leverage the latest hardware advancements and user experience trends\u2026</p>\n<p><strong>Analogy</strong><br>Consider the evolution of automotive technology\u200a\u2014\u200afrom basic, manual cars to sophisticated vehicles equipped with self-driving features and advanced safety systems. The Java API Framework is on a similar trajectory, continually upgrading its features and capabilities. As newer \u201cmodels\u201d of the framework emerge, developers can expect enhanced performance, smarter interfaces, and a more seamless, intuitive driving experience\u200a\u2014\u200aensuring that their apps stay ahead of the technological curve\u2026</p>\n<h3>UP NEXT</h3>\n<p>The System Apps: <a href=\"https://medium.com/@emmanuelmuturia/97413b19dca1\">https://medium.com/@emmanuelmuturia/97413b19dca1</a></p>\n<h3>CONCLUSION</h3>\n<p>Apart from the desire to drive your Car right now, I hope that you have now gotten a better and more technical understanding of The J*va API Framework in the context [pun intended] of The Android Architecture. Stay tuned for both a higher-level summary of this topic as well as the next layer of The Android Architecture. Until then, I hope that you remember what you learned today each time you go for your road trip\u00a0:)\u2026</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/498/0*IcGouFB37jkyhMqF.gif\"></figure><h3>REFERENCES</h3>\n<p><em>Platform Architecture</em>. (2023, May 4). Android Developers. <a href=\"https://developer.android.com/guide/platform\">https://developer.android.com/guide/platform</a></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=74fb865f6431\" width=\"1\" height=\"1\" alt=\"\">\n","content":"\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/617/1*igYWo-4_kiuMXGpwPk1OTw.png\"></figure><p>Well done, dear reader. You are more than halfway there. Before you applaud yourself, though, I need to warn you about this article. While I value the impact of the layer that will be discussed today, you need to be wary of the technology behind it. Rumour has it that it was almost rendered obsolete in the world of Android once its successor took over since the year 2017. Yes. That is what we are dealing with today. Anyway, this article talks about the different APIs that are responsible for the rich features of Android and how they work together to bring Android apps [both Developer Apps and System Apps] to life. Today, we will be talking about <strong>The J*va API Framework</strong>\u2026</p>\n<h3>1. Overview: What Is the J*va API Framework?</h3>\n<p>The J*va API Framework is the cornerstone of Android application development. It is a vast collection of classes, interfaces, and libraries built primarily on J*va (and increasingly Kotlin) that developers use to build applications. This framework provides everything from UI components and system services to networking, data management, and more. It abstracts complex underlying system operations and offers a standardized set of tools that ensure apps can interact consistently with the Android operating system across different devices\u2026</p>\n<p><strong>Analogy</strong><br>Think of the J*va API Framework as the car\u2019s dashboard and control center. Just as a driver uses the dashboard to monitor speed, fuel, and engine status without needing to understand the intricacies of the engine, developers use the API to control and interact with the device\u2019s functionalities without diving into low-level system\u00a0details\u2026</p>\n<h3>2. Core Components: Standard Libraries and Essential Services</h3>\n<p>At its heart, the framework comprises a collection of core libraries and packages\u200a\u2014\u200asuch as java.lang, java.util, and Android-specific packages like android.app, android.content, android.view, and more. These libraries provide fundamental services including event handling, resource management, layout rendering, and connectivity. They serve as modular building blocks that facilitate the rapid development of robust applications by providing pre-built, well-tested functionality\u2026</p>\n<p><strong>Analogy</strong><br>Imagine these core libraries as the standard components found in every modern car\u200a\u2014\u200alike the engine, transmission, braking system, and infotainment controls. These parts are designed to work seamlessly together, giving you a reliable and familiar experience regardless of the car\u2019s brand, much like how the Java API Framework provides a consistent set of tools for app development\u2026</p>\n<h3>3. Application Components and Architecture</h3>\n<p>The framework defines the structure and lifecycle of key Android application components such as Activities, Services, BroadcastReceivers, and Content Providers. These components dictate how apps manage user interactions, background processes, and data exchange. The framework enforces architectural patterns [e.g., MVC, MVP, MVVM] to ensure that apps are scalable, maintainable, and responsive. It also governs the flow of information and control among these components to provide a coherent and integrated user experience\u2026</p>\n<p><strong>Analogy</strong><br>Consider these application components as the different subsystems of a car. An Activity is like the car\u2019s main driving mode, Services resemble the background systems such as climate control or navigation, BroadcastReceivers act like the car\u2019s warning lights that alert you to changes, and Content Providers are akin to the car\u2019s storage compartments that organize your gear. Together, they form a well-orchestrated system that delivers a smooth and reliable driving experience\u2026</p>\n<h3>4. Abstraction and Ease-of-Use: Simplifying Complexity</h3>\n<p>One of the primary strengths of the Java API Framework is its ability to abstract complex operations into simple, high-level interfaces. This abstraction hides the intricate details of hardware management, network protocols, and system security from developers. Instead of writing low-level code, developers can invoke straightforward methods to perform complex tasks such as drawing graphics, handling user input, or accessing remote data. This approach not only accelerates development but also reduces the likelihood of\u00a0errors\u2026</p>\n<p><strong>Analogy</strong><br>Think of this abstraction as the car\u2019s steering wheel and pedals. You don\u2019t need to understand the combustion process or the intricacies of the suspension system to steer, accelerate, or brake. The intuitive controls simplify the driving process, just as the J*va API Framework simplifies app development by hiding complex system internals behind user-friendly interfaces\u2026</p>\n<h3>5. Consistency and Integration: A Unified Development Experience</h3>\n<p>The Java API Framework ensures that all Android applications have a consistent behavior across diverse hardware and software configurations. It integrates seamlessly with other critical layers of the Android ecosystem, such as the Android Runtime (ART), the Hardware Abstraction Layer (HAL), and native libraries. This integration allows developers to build applications that can leverage system resources efficiently, adhere to best practices for security and performance, and provide a uniform user experience regardless of the underlying device architecture\u2026</p>\n<p><strong>Analogy</strong><br>Imagine driving on a highway where every vehicle, regardless of its make or model, follows the same road rules and uses standardized road signs. The consistent framework acts like this standardized system, ensuring that every \u201cdriver\u201d (app) interacts predictably with the \u201croad\u201d (device), leading to a smooth and harmonious journey for everyone\u2026</p>\n<h3>6. Development Tools and Ecosystem Support</h3>\n<p>The Java API Framework is supported by a robust ecosystem of development tools and environments\u200a\u2014\u200amost notably Android Studio. These tools offer features like code autocompletion, real-time debugging, profiling, and extensive documentation that streamline the development process. They empower developers to design, test, and refine their applications with efficiency and precision. Additionally, comprehensive API documentation and community resources help troubleshoot issues and encourage best practices across the developer community\u2026</p>\n<p><strong>Analogy</strong><br>Think of these development tools as the car\u2019s Onboard Diagnostics System [OBD] and navigation aids. Just as these systems help you monitor your car\u2019s health, troubleshoot issues, and plan the best routes, the ecosystem surrounding the Java API Framework guides developers through building high-quality applications by providing real-time feedback, suggestions, and a wealth of information to keep the \u201cvehicle\u201d of your app in top\u00a0shape\u2026</p>\n<h3>7. Evolution and Future Trends: Driving Innovation Forward</h3>\n<p>The J*va API Framework is continuously evolving to meet the demands of modern application development. It adapts to new programming paradigms such as reactive programming and functional interfaces, and it integrates smoothly with newer languages like Kotlin. Ongoing improvements in performance, security, and developer ergonomics ensure that the framework remains at the cutting edge of mobile technology. This evolution enables developers to build innovative applications that leverage the latest hardware advancements and user experience trends\u2026</p>\n<p><strong>Analogy</strong><br>Consider the evolution of automotive technology\u200a\u2014\u200afrom basic, manual cars to sophisticated vehicles equipped with self-driving features and advanced safety systems. The Java API Framework is on a similar trajectory, continually upgrading its features and capabilities. As newer \u201cmodels\u201d of the framework emerge, developers can expect enhanced performance, smarter interfaces, and a more seamless, intuitive driving experience\u200a\u2014\u200aensuring that their apps stay ahead of the technological curve\u2026</p>\n<h3>UP NEXT</h3>\n<p>The System Apps: <a href=\"https://medium.com/@emmanuelmuturia/97413b19dca1\">https://medium.com/@emmanuelmuturia/97413b19dca1</a></p>\n<h3>CONCLUSION</h3>\n<p>Apart from the desire to drive your Car right now, I hope that you have now gotten a better and more technical understanding of The J*va API Framework in the context [pun intended] of The Android Architecture. Stay tuned for both a higher-level summary of this topic as well as the next layer of The Android Architecture. Until then, I hope that you remember what you learned today each time you go for your road trip\u00a0:)\u2026</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/498/0*IcGouFB37jkyhMqF.gif\"></figure><h3>REFERENCES</h3>\n<p><em>Platform Architecture</em>. (2023, May 4). Android Developers. <a href=\"https://developer.android.com/guide/platform\">https://developer.android.com/guide/platform</a></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=74fb865f6431\" width=\"1\" height=\"1\" alt=\"\">\n","enclosure":{},"categories":["java-apis","androiddev","api","android-app-development","android"]},{"title":"The Android Architecture [feat. Native C/C++ Libraries &amp; Android Runtime]","pubDate":"2025-03-18 04:02:34","link":"https://medium.com/@emmanuelmuturia/8f9e05ede41b?source=rss-6256c7dbb031------2","guid":"https://medium.com/p/8f9e05ede41b","author":"Emmanuel Muturia\u2122","thumbnail":"","description":"\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/858/1*mLWUg8WDqAgGTDlemq70wQ.png\"></figure><p>They say that \u201cThird time\u2019s a charm\u201d. While I am still not sure who \u201cthey\u201d refers to, I agree with them because today\u2019s article is a special one as it talks about not 1 but 2 components of The Android Architecture. Previously, we learnt that The Hardware Abstraction Layer [HAL]provides the rest of Android access to The Linux Kernel, which is the core of the OS. Now, have you ever wondered what the building blocks of these components are? Also, have you asked yourself how all those Android apps can run on a single device without instantly depleting its battery level due to their unique performance requirements. If that is you, then this is your article for it talks about <strong>The NativeC/C++ Libraries</strong> and <strong>The Android Runtime</strong>. Again, the Car analogy will be used for illustration purposes\u2026</p>\n<h3>1. Overview: What Are\u00a0They?</h3>\n<p>The Native C/C++ Libraries are a set of core, low-level libraries written in C and C++ that power performance-critical tasks\u200a\u2014\u200asuch as graphics rendering, media processing, and hardware access\u200a\u2014\u200awithin\u00a0Android\u2026</p>\n<p>In contrast, the Android Runtime [ART] is the managed runtime environment that executes Android applications. ART replaces Dalvik with Ahead-Of-Time [AOT] and Just-In-Time [JIT] compilation techniques, advanced garbage collection, and improved memory management. Together, these components form the backbone of Android\u2019s performance: the native libraries provide near\u2013hardware-level speed and efficiency, while ART manages application execution with smart optimizations\u2026</p>\n<p><strong>Analogy</strong><br>Think of the Native C/C++ Libraries as the car\u2019s finely engineered engine and essential mechanical components that deliver raw horsepower. ART, on the other hand, is like the sophisticated onboard computer system that monitors, optimizes, and adapts engine performance in real time. Together, they ensure your vehicle not only has the power to accelerate but also runs smoothly and efficiently\u2026</p>\n<h3>2. Performance and Efficiency: Raw Power and Optimised Control</h3>\n<p>Native libraries are compiled to machine code, allowing them to run with minimal overhead and at near-hardware speeds. This makes them ideal for tasks that demand high performance, such as 3D graphics or real-time media processing. ART enhances this performance by compiling apps Ahead-Of-Time [AOT] for fast startup and using Just-In-Time [JIT] compilation to optimise frequently executed code paths during runtime. Additionally, ART\u2019s efficient garbage collection ensures that memory is reclaimed promptly, keeping the system responsive even under heavy workloads\u2026</p>\n<p><strong>Analogy</strong><br>Imagine the native libraries as a high-performance engine built for raw power, capable of delivering maximum horsepower. ART is the finely tuned transmission and Engine Control Unit [ECU] that adjusts gear ratios on the fly, ensuring that the raw power is harnessed smoothly and efficiently. Together, they provide both the muscle and the smart control that let your car accelerate quickly and maintain peak performance under various driving conditions\u2026</p>\n<h3>3. Standardised APIs and Integration: Consistency Across the\u00a0Board</h3>\n<p>The Android Native Development Kit [NDK] provides a consistent set of APIs that allow developers to harness the power of native libraries, ensuring that performance-critical code works uniformly across different hardware. ART leverages the J*va Native Interface [JNI] to bridge the gap between managed Java/Kotlin code and native C/C++ code, enabling seamless interoperability. This standardised approach minimizes fragmentation, ensures compatibility, and allows both layers to work in concert without the developer needing to manage low-level hardware specifics\u2026</p>\n<p><strong>Analogy</strong><br>Picture a car assembly line where every vehicle is built with standardised components\u200a\u2014\u200aengines, brakes, and electronics\u200a\u2014\u200athat ensure consistent performance across models. The integration via JNI is like a finely engineered gear shift that smoothly transitions power from the engine to the drivetrain, ensuring the car operates reliably regardless of individual parts. In this way, both the native libraries and ART work together under a unified standard, much like standardized car parts ensure a dependable driving experience\u2026</p>\n<h3>4. Graphics, Media, and Real-Time Operations: Handling the High-Octane Tasks</h3>\n<p>Native libraries, including OpenGL ES, Vulkan, and media frameworks like libstagefright, are optimized for intensive graphics rendering and media processing tasks. They provide the raw computational power necessary for high-quality visuals and real-time audio/video playback. ART complements these capabilities by ensuring that the application code, which may invoke these libraries frequently, runs with minimal overhead through dynamic optimizations. This cooperation results in a smooth, responsive user experience even during resource-intensive operations\u2026</p>\n<p><strong>Analogy</strong><br>Think of the native libraries as a turbocharged engine that delivers instantaneous power for rapid acceleration and dynamic performance\u200a\u2014\u200aideal for high-speed racing. ART acts like an adaptive transmission that seamlessly shifts gears based on driving conditions, ensuring that every burst of power is effectively translated into smooth motion. Combined, they create a driving experience where raw performance and refined control work together to handle even the most demanding scenarios\u2026</p>\n<h3>5. Memory Management and Garbage Collection: Sustaining the\u00a0Drive</h3>\n<p>Native C/C++ code is designed for direct and efficient memory management, often requiring the developer to handle allocation and deallocation with care. ART introduces an advanced garbage collection mechanism that automates memory reclamation, reducing the risk of leaks and latency issues. This synergy ensures that while native libraries provide the power through efficient, low-level memory operations, ART keeps the system\u2019s memory clean and well-organized, maintaining high performance and stability over prolonged use\u2026</p>\n<p><strong>Analogy</strong><br>Imagine the native memory management as the car\u2019s precise fuel injection system that delivers just the right amount of fuel to each engine component, ensuring optimal performance. ART\u2019s garbage collection is akin to an automated maintenance system that continuously cleans and adjusts the engine, preventing clogs and wear. Together, they keep your car running at peak efficiency\u200a\u2014\u200aalways ready for the next drive without unexpected breakdowns\u2026</p>\n<h3>6. Debugging, Profiling, and Optimisation: Tuning the\u00a0Machine</h3>\n<p>A robust ecosystem of tools\u200a\u2014\u200asuch as systrace, gdb, and performance profilers\u200a\u2014\u200ais available to diagnose and optimize both native libraries and ART\u2019s execution. Developers can profile low-level C/C++ code for bottlenecks, memory leaks, or inefficient loops, while ART\u2019s diagnostic tools provide insights into runtime behavior, garbage collection events, and JIT performance. This comprehensive approach to debugging and optimization ensures that applications are not only high-performing but also reliable and resource-efficient under diverse conditions\u2026</p>\n<p><strong>Analogy</strong><br>Think of it as having a state-of-the-art onboard diagnostic system in your sports car that continuously monitors engine performance, fuel efficiency, and mechanical integrity. Advanced diagnostic tools help mechanics fine-tune the engine and transmission, ensuring peak performance. Similarly, the debugging and profiling tools for native libraries and ART work together to \u201ctune\u201d your Android device, ensuring that every component operates in harmony for the ultimate driving experience\u2026</p>\n<h3>7. Evolution and Future Trends: Driving Innovation Forward</h3>\n<p>Both the Native C/C++ Libraries and ART are evolving rapidly to meet the demands of next-generation Android applications. Modern C/C++ standards (like C++11 and beyond) and improved compiler optimisations continue to enhance native performance, while ART is integrating predictive optimizations, machine learning techniques, and more efficient memory management strategies. These advancements pave the way for new hardware innovations, better energy efficiency, and more secure and responsive applications\u200a\u2014\u200aensuring that Android remains at the cutting edge of mobile technology\u2026</p>\n<p><strong>Analogy</strong><br>Consider this the evolution of automotive technology\u200a\u2014\u200afrom traditional internal combustion engines to smart, hybrid, and electric vehicles equipped with advanced driver-assistance systems. Just as modern cars are continually upgraded with innovations to enhance safety, performance, and efficiency, the native libraries and ART are being reengineered to deliver a futuristic driving experience. Together, they ensure that your Android \u201cvehicle\u201d stays ahead of the curve, ready to tackle tomorrow\u2019s challenges with state-of-the-art technology\u2026</p>\n<h3>UP NEXT</h3>\n<p>The J*va API Framework: <a href=\"https://medium.com/@emmanuelmuturia/74fb865f6431\">https://medium.com/@emmanuelmuturia/74fb865f6431</a></p>\n<h3>CONCLUSION</h3>\n<p>Apart from the desire to drive your Car right now, I hope that you have now gotten a better and more technical understanding of The Native C/C++ Libraries and Android Runtime [ART] in the context [pun intended] of The Android Architecture. Stay tuned for both a higher-level summary of this topic as well as the next layer of The Android Architecture. Until then, I hope that you remember what you learned today each time you go for your road trip\u00a0:)\u2026</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/498/0*iR_mm-L3aLPAw-vK.gif\"></figure><h3>REFERENCES</h3>\n<p><em>Platform Architecture</em>. (2023, May 4). Android Developers. <a href=\"https://developer.android.com/guide/platform\">https://developer.android.com/guide/platform</a></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=8f9e05ede41b\" width=\"1\" height=\"1\" alt=\"\">\n","content":"\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/858/1*mLWUg8WDqAgGTDlemq70wQ.png\"></figure><p>They say that \u201cThird time\u2019s a charm\u201d. While I am still not sure who \u201cthey\u201d refers to, I agree with them because today\u2019s article is a special one as it talks about not 1 but 2 components of The Android Architecture. Previously, we learnt that The Hardware Abstraction Layer [HAL]provides the rest of Android access to The Linux Kernel, which is the core of the OS. Now, have you ever wondered what the building blocks of these components are? Also, have you asked yourself how all those Android apps can run on a single device without instantly depleting its battery level due to their unique performance requirements. If that is you, then this is your article for it talks about <strong>The NativeC/C++ Libraries</strong> and <strong>The Android Runtime</strong>. Again, the Car analogy will be used for illustration purposes\u2026</p>\n<h3>1. Overview: What Are\u00a0They?</h3>\n<p>The Native C/C++ Libraries are a set of core, low-level libraries written in C and C++ that power performance-critical tasks\u200a\u2014\u200asuch as graphics rendering, media processing, and hardware access\u200a\u2014\u200awithin\u00a0Android\u2026</p>\n<p>In contrast, the Android Runtime [ART] is the managed runtime environment that executes Android applications. ART replaces Dalvik with Ahead-Of-Time [AOT] and Just-In-Time [JIT] compilation techniques, advanced garbage collection, and improved memory management. Together, these components form the backbone of Android\u2019s performance: the native libraries provide near\u2013hardware-level speed and efficiency, while ART manages application execution with smart optimizations\u2026</p>\n<p><strong>Analogy</strong><br>Think of the Native C/C++ Libraries as the car\u2019s finely engineered engine and essential mechanical components that deliver raw horsepower. ART, on the other hand, is like the sophisticated onboard computer system that monitors, optimizes, and adapts engine performance in real time. Together, they ensure your vehicle not only has the power to accelerate but also runs smoothly and efficiently\u2026</p>\n<h3>2. Performance and Efficiency: Raw Power and Optimised Control</h3>\n<p>Native libraries are compiled to machine code, allowing them to run with minimal overhead and at near-hardware speeds. This makes them ideal for tasks that demand high performance, such as 3D graphics or real-time media processing. ART enhances this performance by compiling apps Ahead-Of-Time [AOT] for fast startup and using Just-In-Time [JIT] compilation to optimise frequently executed code paths during runtime. Additionally, ART\u2019s efficient garbage collection ensures that memory is reclaimed promptly, keeping the system responsive even under heavy workloads\u2026</p>\n<p><strong>Analogy</strong><br>Imagine the native libraries as a high-performance engine built for raw power, capable of delivering maximum horsepower. ART is the finely tuned transmission and Engine Control Unit [ECU] that adjusts gear ratios on the fly, ensuring that the raw power is harnessed smoothly and efficiently. Together, they provide both the muscle and the smart control that let your car accelerate quickly and maintain peak performance under various driving conditions\u2026</p>\n<h3>3. Standardised APIs and Integration: Consistency Across the\u00a0Board</h3>\n<p>The Android Native Development Kit [NDK] provides a consistent set of APIs that allow developers to harness the power of native libraries, ensuring that performance-critical code works uniformly across different hardware. ART leverages the J*va Native Interface [JNI] to bridge the gap between managed Java/Kotlin code and native C/C++ code, enabling seamless interoperability. This standardised approach minimizes fragmentation, ensures compatibility, and allows both layers to work in concert without the developer needing to manage low-level hardware specifics\u2026</p>\n<p><strong>Analogy</strong><br>Picture a car assembly line where every vehicle is built with standardised components\u200a\u2014\u200aengines, brakes, and electronics\u200a\u2014\u200athat ensure consistent performance across models. The integration via JNI is like a finely engineered gear shift that smoothly transitions power from the engine to the drivetrain, ensuring the car operates reliably regardless of individual parts. In this way, both the native libraries and ART work together under a unified standard, much like standardized car parts ensure a dependable driving experience\u2026</p>\n<h3>4. Graphics, Media, and Real-Time Operations: Handling the High-Octane Tasks</h3>\n<p>Native libraries, including OpenGL ES, Vulkan, and media frameworks like libstagefright, are optimized for intensive graphics rendering and media processing tasks. They provide the raw computational power necessary for high-quality visuals and real-time audio/video playback. ART complements these capabilities by ensuring that the application code, which may invoke these libraries frequently, runs with minimal overhead through dynamic optimizations. This cooperation results in a smooth, responsive user experience even during resource-intensive operations\u2026</p>\n<p><strong>Analogy</strong><br>Think of the native libraries as a turbocharged engine that delivers instantaneous power for rapid acceleration and dynamic performance\u200a\u2014\u200aideal for high-speed racing. ART acts like an adaptive transmission that seamlessly shifts gears based on driving conditions, ensuring that every burst of power is effectively translated into smooth motion. Combined, they create a driving experience where raw performance and refined control work together to handle even the most demanding scenarios\u2026</p>\n<h3>5. Memory Management and Garbage Collection: Sustaining the\u00a0Drive</h3>\n<p>Native C/C++ code is designed for direct and efficient memory management, often requiring the developer to handle allocation and deallocation with care. ART introduces an advanced garbage collection mechanism that automates memory reclamation, reducing the risk of leaks and latency issues. This synergy ensures that while native libraries provide the power through efficient, low-level memory operations, ART keeps the system\u2019s memory clean and well-organized, maintaining high performance and stability over prolonged use\u2026</p>\n<p><strong>Analogy</strong><br>Imagine the native memory management as the car\u2019s precise fuel injection system that delivers just the right amount of fuel to each engine component, ensuring optimal performance. ART\u2019s garbage collection is akin to an automated maintenance system that continuously cleans and adjusts the engine, preventing clogs and wear. Together, they keep your car running at peak efficiency\u200a\u2014\u200aalways ready for the next drive without unexpected breakdowns\u2026</p>\n<h3>6. Debugging, Profiling, and Optimisation: Tuning the\u00a0Machine</h3>\n<p>A robust ecosystem of tools\u200a\u2014\u200asuch as systrace, gdb, and performance profilers\u200a\u2014\u200ais available to diagnose and optimize both native libraries and ART\u2019s execution. Developers can profile low-level C/C++ code for bottlenecks, memory leaks, or inefficient loops, while ART\u2019s diagnostic tools provide insights into runtime behavior, garbage collection events, and JIT performance. This comprehensive approach to debugging and optimization ensures that applications are not only high-performing but also reliable and resource-efficient under diverse conditions\u2026</p>\n<p><strong>Analogy</strong><br>Think of it as having a state-of-the-art onboard diagnostic system in your sports car that continuously monitors engine performance, fuel efficiency, and mechanical integrity. Advanced diagnostic tools help mechanics fine-tune the engine and transmission, ensuring peak performance. Similarly, the debugging and profiling tools for native libraries and ART work together to \u201ctune\u201d your Android device, ensuring that every component operates in harmony for the ultimate driving experience\u2026</p>\n<h3>7. Evolution and Future Trends: Driving Innovation Forward</h3>\n<p>Both the Native C/C++ Libraries and ART are evolving rapidly to meet the demands of next-generation Android applications. Modern C/C++ standards (like C++11 and beyond) and improved compiler optimisations continue to enhance native performance, while ART is integrating predictive optimizations, machine learning techniques, and more efficient memory management strategies. These advancements pave the way for new hardware innovations, better energy efficiency, and more secure and responsive applications\u200a\u2014\u200aensuring that Android remains at the cutting edge of mobile technology\u2026</p>\n<p><strong>Analogy</strong><br>Consider this the evolution of automotive technology\u200a\u2014\u200afrom traditional internal combustion engines to smart, hybrid, and electric vehicles equipped with advanced driver-assistance systems. Just as modern cars are continually upgraded with innovations to enhance safety, performance, and efficiency, the native libraries and ART are being reengineered to deliver a futuristic driving experience. Together, they ensure that your Android \u201cvehicle\u201d stays ahead of the curve, ready to tackle tomorrow\u2019s challenges with state-of-the-art technology\u2026</p>\n<h3>UP NEXT</h3>\n<p>The J*va API Framework: <a href=\"https://medium.com/@emmanuelmuturia/74fb865f6431\">https://medium.com/@emmanuelmuturia/74fb865f6431</a></p>\n<h3>CONCLUSION</h3>\n<p>Apart from the desire to drive your Car right now, I hope that you have now gotten a better and more technical understanding of The Native C/C++ Libraries and Android Runtime [ART] in the context [pun intended] of The Android Architecture. Stay tuned for both a higher-level summary of this topic as well as the next layer of The Android Architecture. Until then, I hope that you remember what you learned today each time you go for your road trip\u00a0:)\u2026</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/498/0*iR_mm-L3aLPAw-vK.gif\"></figure><h3>REFERENCES</h3>\n<p><em>Platform Architecture</em>. (2023, May 4). Android Developers. <a href=\"https://developer.android.com/guide/platform\">https://developer.android.com/guide/platform</a></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=8f9e05ede41b\" width=\"1\" height=\"1\" alt=\"\">\n","enclosure":{},"categories":["androiddev","android","cplusplus","android-app-development","c-programming"]},{"title":"The Android Architecture [feat. The Hardware Abstraction Layer]","pubDate":"2025-03-11 04:02:30","link":"https://medium.com/@emmanuelmuturia/3dbb6e96cd43?source=rss-6256c7dbb031------2","guid":"https://medium.com/p/3dbb6e96cd43","author":"Emmanuel Muturia\u2122","thumbnail":"","description":"\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/642/1*Gqi51lPeWo6Z-EGVL8SwnA.png\"></figure><p>Previously on whatever this series is called, we talked about The Linux Kernel and everything about it concerning The Android Architecture. Today, we will be moving a notch higher, literally. Of course, The Linux Kernel would be useless to Android if it was not accessible. Since accessing it directly would be quite complex, there is a layer whose sole purpose is to make this accessibility a little bit easier. Today, you will be learning more about <strong>The Hardware Abstraction Layer [HAL]</strong> and yes, we will be using a Car analogy like we did last time so buckle\u00a0up\u2026</p>\n<h3>1. What is the Hardware Abstraction Layer\u00a0[HAL]?</h3>\n<p>The Hardware Abstraction Layer [HAL] is a vital layer in Android\u2019s architecture that serves as the intermediary between the Android Framework and the device\u2019s low-level hardware drivers. Written mostly in C/C++, it defines a set of standard APIs that encapsulate the specifics of hardware operations. By providing a uniform interface, the HAL allows higher-level Android services to interact with a wide range of hardware implementations without needing to understand each device\u2019s unique details. This modular structure not only speeds up development but also ensures compatibility across diverse hardware configurations\u2026</p>\n<p><strong>Analogy</strong><br>Think of the HAL as the car\u2019s central control module that abstracts the engine\u2019s intricate workings. Just as a driver doesn\u2019t need to know how fuel injection, ignition timing, or turbo boosting work to drive the car, Android developers can rely on the HAL to handle the low-level hardware interactions. It enables you to focus on the \u201cdriving\u201d [building your app] without needing to understand every mechanical detail\u2026</p>\n<h3>2. Standardised Interface: The Universal Dashboard</h3>\n<p>The HAL establishes standardised interfaces that hardware vendors must implement, which means that regardless of the manufacturer or specific hardware variations, the Android Framework communicates through a consistent set of function calls. These interfaces are often defined in hardware-specific libraries and are critical for ensuring that disparate hardware components behave predictably. This standardisation minimises fragmentation and simplifies the integration of new hardware into the Android ecosystem\u2026</p>\n<p><strong>Analogy</strong><br>Imagine every car having a universal dashboard. No matter the make or model, the controls\u200a\u2014\u200abe it for climate, navigation, or entertainment\u200a\u2014\u200aare laid out in a familiar pattern. Similarly, HAL provides a \u201cdashboard\u201d of APIs that ensure uniform control over hardware components, so that the Android system can operate every device with the same set of commands\u2026</p>\n<h3>3. Modularity: Plug-and-Play Components</h3>\n<p>The design of the HAL is modular, meaning that each hardware component (like the camera, GPS, or Bluetooth) has its own dedicated module. These modules can be independently developed, updated, or replaced without affecting the rest of the system. This plug-and-play nature not only supports hardware diversity but also facilitates faster innovation and easier troubleshooting. Vendors can supply custom modules tailored to their hardware\u2019s capabilities while still adhering to the standard HAL interface\u2026</p>\n<p><strong>Analogy</strong><br>Think of it as a car built with modular components: you can swap out the stereo, upgrade the air conditioning, or replace the navigation system independently. Each module works as a self-contained unit that plugs into the car\u2019s overall system, ensuring that even if one component is upgraded or replaced, the rest of the vehicle continues to operate seamlessly\u2026</p>\n<h3>4. Bridging Framework and Drivers: The Wiring\u00a0Harness</h3>\n<p>The HAL acts as the critical bridge between the Android Framework and the underlying hardware drivers. When an application requests a hardware service, the request passes through the Android Framework, reaches the HAL, and is then translated into low-level commands that the hardware drivers understand. This process involves Inter-Process Communication (IPC) mechanisms and well-defined protocols that ensure commands are executed correctly and efficiently. The HAL essentially decouples the high-level application logic from the low-level hardware operations\u2026</p>\n<p><strong>Analogy</strong><br>Imagine the car\u2019s wiring harness\u200a\u2014\u200aa network of wires and control modules that links the dashboard controls to the engine, brakes, and other subsystems. When you press the accelerator or apply the brakes, signals travel through this harness to enact the desired response. Similarly, the HAL translates and routes software commands from the Android Framework to the correct hardware driver, ensuring every \u201csignal\u201d reaches its destination accurately...</p>\n<h3>5. Vendor Customisation: Tailored Features Under the\u00a0Hood</h3>\n<p>While the HAL sets the standard for hardware interaction, it also allows vendors some flexibility to implement device-specific features. Manufacturers can create custom HAL modules that expose additional capabilities unique to their hardware. This means that while basic functionality remains consistent across devices, specialised features\u200a\u2014\u200alike advanced camera capabilities or proprietary sensor functions\u200a\u2014\u200acan be integrated without disrupting the overall system architecture. This balance between standardisation and customisation is key to Android\u2019s versatility\u2026</p>\n<p><strong>Analogy</strong><br>Think of this as car manufacturers offering branded enhancements\u200a\u2014\u200alike a premium sound system, sport-tuned suspension, or an advanced infotainment package. Even though every car adheres to basic controls and safety features, these extra touches allow each manufacturer to offer a unique driving experience. In the same way, vendor-specific HAL modules add tailored functionality while still interfacing with Android\u2019s standardised framework\u2026</p>\n<h3>6. Performance and Responsiveness: Optimising The\u00a0Drive</h3>\n<p>An efficiently implemented HAL is critical for achieving high performance and responsiveness in an Android device. By minimizing the overhead in communication between the Android Framework and hardware drivers, the HAL contributes directly to faster execution of hardware commands and better overall system performance. This efficiency is particularly important for tasks that demand real-time processing, such as multimedia rendering or sensor data processing, where delays can negatively impact user experience.</p>\n<p><strong>Analogy</strong><br>Consider the role of an optimised Engine Control Unit (ECU) in a high-performance car. When the ECU efficiently processes sensor data and adjusts engine parameters on the fly, the car delivers smooth acceleration and responsiveness. Likewise, an optimized HAL ensures that hardware commands are processed swiftly, translating into a more responsive and efficient device\u200a\u2014\u200amuch like the seamless performance of a finely tuned\u00a0car\u2026</p>\n<h3>7. Evolution and Future of HAL: Upgrading Your\u00a0Ride</h3>\n<p>As new hardware technologies and capabilities emerge, the HAL must evolve to support these advancements. This ongoing development is essential for integrating next-generation components, such as augmented reality sensors or AI accelerators, into the Android ecosystem. Developers and hardware vendors work together to update HAL specifications and interfaces, ensuring backward compatibility while enabling innovation. This evolution not only supports improved functionality and performance but also helps maintain a cohesive ecosystem despite rapid technological changes.</p>\n<p><strong>Analogy</strong><br>This is similar to the evolution of cars\u200a\u2014\u200afrom basic combustion engines to sophisticated hybrids and electric vehicles equipped with autonomous driving features. Just as cars receive periodic upgrades and new technologies to enhance performance and safety, the HAL is continuously refined to incorporate cutting-edge hardware advancements, ensuring that your \u201cvehicle\u201d [Android device] remains state-of-the-art\u2026</p>\n<h3>UP NEXT</h3>\n<p>The Native C/C++ Libraries and Android Runtime: <a href=\"https://medium.com/@emmanuelmuturia/8f9e05ede41b\">https://medium.com/@emmanuelmuturia/8f9e05ede41b</a></p>\n<h3>CONCLUSION</h3>\n<p>Apart from the desire to drive your Car right now, I hope that you have now gotten a better and more technical understanding of The Hardware Abstraction Layer [HAL] in the context [pun intended] of The Android Architecture. Stay tuned for both a higher-level summary of this topic as well as the next layer of The Android Architecture. Until then, I hope that you remember what you learned today each time you go for your road trip\u00a0:)\u2026</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/498/0*IcGouFB37jkyhMqF.gif\"></figure><h3>REFERENCES</h3>\n<p><em>Platform Architecture</em>. (2023, May 4). Android Developers. <a href=\"https://developer.android.com/guide/platform\">https://developer.android.com/guide/platform</a></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=3dbb6e96cd43\" width=\"1\" height=\"1\" alt=\"\">\n","content":"\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/642/1*Gqi51lPeWo6Z-EGVL8SwnA.png\"></figure><p>Previously on whatever this series is called, we talked about The Linux Kernel and everything about it concerning The Android Architecture. Today, we will be moving a notch higher, literally. Of course, The Linux Kernel would be useless to Android if it was not accessible. Since accessing it directly would be quite complex, there is a layer whose sole purpose is to make this accessibility a little bit easier. Today, you will be learning more about <strong>The Hardware Abstraction Layer [HAL]</strong> and yes, we will be using a Car analogy like we did last time so buckle\u00a0up\u2026</p>\n<h3>1. What is the Hardware Abstraction Layer\u00a0[HAL]?</h3>\n<p>The Hardware Abstraction Layer [HAL] is a vital layer in Android\u2019s architecture that serves as the intermediary between the Android Framework and the device\u2019s low-level hardware drivers. Written mostly in C/C++, it defines a set of standard APIs that encapsulate the specifics of hardware operations. By providing a uniform interface, the HAL allows higher-level Android services to interact with a wide range of hardware implementations without needing to understand each device\u2019s unique details. This modular structure not only speeds up development but also ensures compatibility across diverse hardware configurations\u2026</p>\n<p><strong>Analogy</strong><br>Think of the HAL as the car\u2019s central control module that abstracts the engine\u2019s intricate workings. Just as a driver doesn\u2019t need to know how fuel injection, ignition timing, or turbo boosting work to drive the car, Android developers can rely on the HAL to handle the low-level hardware interactions. It enables you to focus on the \u201cdriving\u201d [building your app] without needing to understand every mechanical detail\u2026</p>\n<h3>2. Standardised Interface: The Universal Dashboard</h3>\n<p>The HAL establishes standardised interfaces that hardware vendors must implement, which means that regardless of the manufacturer or specific hardware variations, the Android Framework communicates through a consistent set of function calls. These interfaces are often defined in hardware-specific libraries and are critical for ensuring that disparate hardware components behave predictably. This standardisation minimises fragmentation and simplifies the integration of new hardware into the Android ecosystem\u2026</p>\n<p><strong>Analogy</strong><br>Imagine every car having a universal dashboard. No matter the make or model, the controls\u200a\u2014\u200abe it for climate, navigation, or entertainment\u200a\u2014\u200aare laid out in a familiar pattern. Similarly, HAL provides a \u201cdashboard\u201d of APIs that ensure uniform control over hardware components, so that the Android system can operate every device with the same set of commands\u2026</p>\n<h3>3. Modularity: Plug-and-Play Components</h3>\n<p>The design of the HAL is modular, meaning that each hardware component (like the camera, GPS, or Bluetooth) has its own dedicated module. These modules can be independently developed, updated, or replaced without affecting the rest of the system. This plug-and-play nature not only supports hardware diversity but also facilitates faster innovation and easier troubleshooting. Vendors can supply custom modules tailored to their hardware\u2019s capabilities while still adhering to the standard HAL interface\u2026</p>\n<p><strong>Analogy</strong><br>Think of it as a car built with modular components: you can swap out the stereo, upgrade the air conditioning, or replace the navigation system independently. Each module works as a self-contained unit that plugs into the car\u2019s overall system, ensuring that even if one component is upgraded or replaced, the rest of the vehicle continues to operate seamlessly\u2026</p>\n<h3>4. Bridging Framework and Drivers: The Wiring\u00a0Harness</h3>\n<p>The HAL acts as the critical bridge between the Android Framework and the underlying hardware drivers. When an application requests a hardware service, the request passes through the Android Framework, reaches the HAL, and is then translated into low-level commands that the hardware drivers understand. This process involves Inter-Process Communication (IPC) mechanisms and well-defined protocols that ensure commands are executed correctly and efficiently. The HAL essentially decouples the high-level application logic from the low-level hardware operations\u2026</p>\n<p><strong>Analogy</strong><br>Imagine the car\u2019s wiring harness\u200a\u2014\u200aa network of wires and control modules that links the dashboard controls to the engine, brakes, and other subsystems. When you press the accelerator or apply the brakes, signals travel through this harness to enact the desired response. Similarly, the HAL translates and routes software commands from the Android Framework to the correct hardware driver, ensuring every \u201csignal\u201d reaches its destination accurately...</p>\n<h3>5. Vendor Customisation: Tailored Features Under the\u00a0Hood</h3>\n<p>While the HAL sets the standard for hardware interaction, it also allows vendors some flexibility to implement device-specific features. Manufacturers can create custom HAL modules that expose additional capabilities unique to their hardware. This means that while basic functionality remains consistent across devices, specialised features\u200a\u2014\u200alike advanced camera capabilities or proprietary sensor functions\u200a\u2014\u200acan be integrated without disrupting the overall system architecture. This balance between standardisation and customisation is key to Android\u2019s versatility\u2026</p>\n<p><strong>Analogy</strong><br>Think of this as car manufacturers offering branded enhancements\u200a\u2014\u200alike a premium sound system, sport-tuned suspension, or an advanced infotainment package. Even though every car adheres to basic controls and safety features, these extra touches allow each manufacturer to offer a unique driving experience. In the same way, vendor-specific HAL modules add tailored functionality while still interfacing with Android\u2019s standardised framework\u2026</p>\n<h3>6. Performance and Responsiveness: Optimising The\u00a0Drive</h3>\n<p>An efficiently implemented HAL is critical for achieving high performance and responsiveness in an Android device. By minimizing the overhead in communication between the Android Framework and hardware drivers, the HAL contributes directly to faster execution of hardware commands and better overall system performance. This efficiency is particularly important for tasks that demand real-time processing, such as multimedia rendering or sensor data processing, where delays can negatively impact user experience.</p>\n<p><strong>Analogy</strong><br>Consider the role of an optimised Engine Control Unit (ECU) in a high-performance car. When the ECU efficiently processes sensor data and adjusts engine parameters on the fly, the car delivers smooth acceleration and responsiveness. Likewise, an optimized HAL ensures that hardware commands are processed swiftly, translating into a more responsive and efficient device\u200a\u2014\u200amuch like the seamless performance of a finely tuned\u00a0car\u2026</p>\n<h3>7. Evolution and Future of HAL: Upgrading Your\u00a0Ride</h3>\n<p>As new hardware technologies and capabilities emerge, the HAL must evolve to support these advancements. This ongoing development is essential for integrating next-generation components, such as augmented reality sensors or AI accelerators, into the Android ecosystem. Developers and hardware vendors work together to update HAL specifications and interfaces, ensuring backward compatibility while enabling innovation. This evolution not only supports improved functionality and performance but also helps maintain a cohesive ecosystem despite rapid technological changes.</p>\n<p><strong>Analogy</strong><br>This is similar to the evolution of cars\u200a\u2014\u200afrom basic combustion engines to sophisticated hybrids and electric vehicles equipped with autonomous driving features. Just as cars receive periodic upgrades and new technologies to enhance performance and safety, the HAL is continuously refined to incorporate cutting-edge hardware advancements, ensuring that your \u201cvehicle\u201d [Android device] remains state-of-the-art\u2026</p>\n<h3>UP NEXT</h3>\n<p>The Native C/C++ Libraries and Android Runtime: <a href=\"https://medium.com/@emmanuelmuturia/8f9e05ede41b\">https://medium.com/@emmanuelmuturia/8f9e05ede41b</a></p>\n<h3>CONCLUSION</h3>\n<p>Apart from the desire to drive your Car right now, I hope that you have now gotten a better and more technical understanding of The Hardware Abstraction Layer [HAL] in the context [pun intended] of The Android Architecture. Stay tuned for both a higher-level summary of this topic as well as the next layer of The Android Architecture. Until then, I hope that you remember what you learned today each time you go for your road trip\u00a0:)\u2026</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/498/0*IcGouFB37jkyhMqF.gif\"></figure><h3>REFERENCES</h3>\n<p><em>Platform Architecture</em>. (2023, May 4). Android Developers. <a href=\"https://developer.android.com/guide/platform\">https://developer.android.com/guide/platform</a></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=3dbb6e96cd43\" width=\"1\" height=\"1\" alt=\"\">\n","enclosure":{},"categories":["hardware","android-app-development","android","abstraction","androiddev"]},{"title":"The Android Architecture [feat. The Linux Kernel]","pubDate":"2025-03-04 04:02:55","link":"https://medium.com/@emmanuelmuturia/5fd3213d4eb2?source=rss-6256c7dbb031------2","guid":"https://medium.com/p/5fd3213d4eb2","author":"Emmanuel Muturia\u2122","thumbnail":"","description":"\n<p>If you are like me, you have probably fallen into the trap of trying to master Android stuff without going into the nooks and crannies. This, of course, results in a stammering session during interviews that you probably have PTSD about. Then again, they said that \u201cThe Devil is in the detail\u201d. I am not sure who \u201cthey\u201d is or how that expression is relevant here but I guess I needed to sound intelligent if I was going to take you through a deeper dive into one of the most popular topics in Android: <strong>The Android Architecture</strong>\u2026</p>\n<h3><strong>THE BACKGROUND</strong></h3>\n<p>While a lot has been happening ever since the creation of Android, the fundamentals remain fundamental to our understanding of not just the OS itself but also the apps that we love to build for it. This article is a fun and technical explainer of the different building blocks that comprise Android. Today, we will be focusing on the deepest layer of The Android Architecture: <strong>The Linux\u00a0Kernel</strong>\u2026</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/665/1*TCqcVb_KMQOrGA9JFK4usA.png\"></figure><h3><strong>1. Overview: What is The Linux\u00a0Kernel?</strong></h3>\n<p>The Linux Kernel is the central component of Android. It acts as the core bridge between hardware and software, managing resources, scheduling tasks, and enforcing security policies. Without it, Android apps would not be able to communicate with the underlying hardware, making it the essential foundation of Android\u2019s functionality\u2026</p>\n<p><strong>Analogy</strong><br>Think of the Linux Kernel as the engine of your car. Just as the engine converts fuel into motion and powers every function of the vehicle, the kernel powers all operations on your Android device. It is the driving force that ensures every component works in harmony, turning user commands into real-world actions\u2026</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*GOtIrPLK9acOVX3s-b-YXg.png\"></figure><h3>2. Process Management: Orchestrating the System\u2019s\u00a0Pulse</h3>\n<p>Process Management in the Linux Kernel is responsible for scheduling, executing, and managing all active processes. It determines the order and duration for which each process uses the CPU, ensuring that system resources are efficiently shared among all running applications\u2026</p>\n<p><strong>Analogy</strong><br>Imagine that Process Management is your car\u2019s transmission system. Just as a transmission shifts gears to optimise the engine\u2019s power output based on driving conditions, the kernel\u2019s scheduler dynamically allocates CPU time to various processes. This careful management prevents \u201ctraffic jams\u201d in processing and ensures smooth, responsive performance\u200a\u2014\u200amuch like a well-tuned car seamlessly shifting through gears during a\u00a0drive\u2026</p>\n<h3>3. Memory Management: Allocating and Optimising Resources</h3>\n<p>Memory Management in the kernel involves dynamically allocating, tracking, and reclaiming Memory for processes. Techniques like Virtual Memory, Paging, and Caching ensure that each application has the necessary space to operate without interfering with others, maintaining system stability and efficiency\u2026</p>\n<p><strong>Analogy</strong><br>Consider that Memory Management is the car\u2019s fuel injection and storage system. Just as fuel injectors precisely deliver the right amount of fuel to each engine cylinder and the car\u2019s compartments are organised to store essentials, the kernel allocates the appropriate amount of memory to each process. This ensures that every part of the \u201cengine\u201d runs at peak performance without overloading any single\u00a0system\u2026</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/220/1*K9MNYUkWm7npJD0T1LPX8A.gif\"></figure><h3>4. Device Drivers: Bridging Hardware and\u00a0Software</h3>\n<p>Device drivers are specialized modules within the kernel that facilitate communication with hardware components\u200a\u2014\u200asuch as cameras, sensors, and displays. They translate high-level commands into device-specific operations, enabling seamless integration between the software and the physical hardware\u2026</p>\n<p><strong>Analogy</strong><br>Think of device drivers as the car\u2019s onboard control modules and wiring systems. They act like the Electronic Control Units [ECUs] that interpret signals from the accelerator, brakes, and steering wheel to coordinate the car\u2019s mechanical responses. In the same way, drivers translate the kernel\u2019s commands into actions that hardware components can execute, ensuring every part of the car [or device] functions correctly\u2026</p>\n<h3>5. File System Management: Organising Data\u00a0Storage</h3>\n<p>The kernel\u2019s File System Management is tasked with organising, storing, and retrieving data on the device. It maintains the structure of directories and files, manages permissions, and ensures data integrity, allowing for fast and secure access to stored information\u2026</p>\n<p><strong>Analogy</strong><br>Imagine that File System Management is the car\u2019s dashboard and central computer that organises vital information. Just as the dashboard displays organised data [speed, fuel level, engine temperature, etc] and the car\u2019s compartments keep everything neatly stored, the kernel organises files and data so that everything is accessible and well-maintained. It is like having a perfectly organised trunk where every tool and accessory has its designated place\u2026</p>\n<h3>6. Inter-Process Communication &amp; System Calls: The Communication Network</h3>\n<p>Inter-process communication [IPC] and System Calls form the channels through which user applications interact with the kernel. These mechanisms allow apps to request services like file access, process control, or hardware operations, ensuring that the kernel can serve as a reliable intermediary between user commands and system-level actions\u2026</p>\n<p><strong>Analogy</strong><br>Think of IPC and System Calls as the car\u2019s internal wiring and sensor network. When you press the accelerator or turn the steering wheel, signals travel through a network of wires to the Engine Control Unit [ECU], which then adjusts performance accordingly. Similarly, the System Calls act as the direct communication lines between applications and the kernel, ensuring that every command is transmitted accurately\u200a\u2014\u200ajust like the reliable wiring that keeps your car running smoothly\u2026</p>\n<h3>7. Security, Customisation, and Performance: Tuning The\u00a0System</h3>\n<p>The kernel incorporates robust security measures\u200a\u2014\u200asuch as SELinux\u200a\u2014\u200ato enforce permissions and protect the system from unauthorised access. Additionally, its modular design allows for customisation and performance tuning through loadable modules and configurable settings. This flexibility enables Android Engineers to optimise the system for specific hardware or application needs\u2026</p>\n<p><strong>Analogy</strong><br>Imagine this aspect as the car\u2019s advanced safety systems and performance tuning options. The kernel\u2019s security features are like airbags, anti-lock brakes, and alarm systems that protect you on the road. Customisation and performance tuning are similar to upgrading your car\u2019s suspension, engine chip, or even selecting different driving modes [Eco, Sport, and Comfort] to tailor the driving experience. These features ensure that your \u201cvehicle\u201d runs safely, efficiently, and exactly to your preferences\u2026</p>\n<h3>UP NEXT</h3>\n<p>The Hardware Abstraction Layer [HAL]: <a href=\"https://medium.com/@emmanuelmuturia/3dbb6e96cd43\">https://medium.com/@emmanuelmuturia/3dbb6e96cd43</a></p>\n<h3>CONCLUSION</h3>\n<p>Apart from the desire to drive your Car right now, I hope that you have now gotten a better and more technical understanding of The Linux Kernel in the context [pun intended] of The Android Architecture. Stay tuned for more content and until then, I hope that you remember what you learned today each time you go for your road trip\u00a0:)\u2026</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/498/0*IcGouFB37jkyhMqF.gif\"></figure><h3><strong>REFERENCES</strong></h3>\n<p><em>Platform Architecture</em>. (2023, May 4). Android Developers. <a href=\"https://developer.android.com/guide/platform\">https://developer.android.com/guide/platform</a></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=5fd3213d4eb2\" width=\"1\" height=\"1\" alt=\"\">\n","content":"\n<p>If you are like me, you have probably fallen into the trap of trying to master Android stuff without going into the nooks and crannies. This, of course, results in a stammering session during interviews that you probably have PTSD about. Then again, they said that \u201cThe Devil is in the detail\u201d. I am not sure who \u201cthey\u201d is or how that expression is relevant here but I guess I needed to sound intelligent if I was going to take you through a deeper dive into one of the most popular topics in Android: <strong>The Android Architecture</strong>\u2026</p>\n<h3><strong>THE BACKGROUND</strong></h3>\n<p>While a lot has been happening ever since the creation of Android, the fundamentals remain fundamental to our understanding of not just the OS itself but also the apps that we love to build for it. This article is a fun and technical explainer of the different building blocks that comprise Android. Today, we will be focusing on the deepest layer of The Android Architecture: <strong>The Linux\u00a0Kernel</strong>\u2026</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/665/1*TCqcVb_KMQOrGA9JFK4usA.png\"></figure><h3><strong>1. Overview: What is The Linux\u00a0Kernel?</strong></h3>\n<p>The Linux Kernel is the central component of Android. It acts as the core bridge between hardware and software, managing resources, scheduling tasks, and enforcing security policies. Without it, Android apps would not be able to communicate with the underlying hardware, making it the essential foundation of Android\u2019s functionality\u2026</p>\n<p><strong>Analogy</strong><br>Think of the Linux Kernel as the engine of your car. Just as the engine converts fuel into motion and powers every function of the vehicle, the kernel powers all operations on your Android device. It is the driving force that ensures every component works in harmony, turning user commands into real-world actions\u2026</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*GOtIrPLK9acOVX3s-b-YXg.png\"></figure><h3>2. Process Management: Orchestrating the System\u2019s\u00a0Pulse</h3>\n<p>Process Management in the Linux Kernel is responsible for scheduling, executing, and managing all active processes. It determines the order and duration for which each process uses the CPU, ensuring that system resources are efficiently shared among all running applications\u2026</p>\n<p><strong>Analogy</strong><br>Imagine that Process Management is your car\u2019s transmission system. Just as a transmission shifts gears to optimise the engine\u2019s power output based on driving conditions, the kernel\u2019s scheduler dynamically allocates CPU time to various processes. This careful management prevents \u201ctraffic jams\u201d in processing and ensures smooth, responsive performance\u200a\u2014\u200amuch like a well-tuned car seamlessly shifting through gears during a\u00a0drive\u2026</p>\n<h3>3. Memory Management: Allocating and Optimising Resources</h3>\n<p>Memory Management in the kernel involves dynamically allocating, tracking, and reclaiming Memory for processes. Techniques like Virtual Memory, Paging, and Caching ensure that each application has the necessary space to operate without interfering with others, maintaining system stability and efficiency\u2026</p>\n<p><strong>Analogy</strong><br>Consider that Memory Management is the car\u2019s fuel injection and storage system. Just as fuel injectors precisely deliver the right amount of fuel to each engine cylinder and the car\u2019s compartments are organised to store essentials, the kernel allocates the appropriate amount of memory to each process. This ensures that every part of the \u201cengine\u201d runs at peak performance without overloading any single\u00a0system\u2026</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/220/1*K9MNYUkWm7npJD0T1LPX8A.gif\"></figure><h3>4. Device Drivers: Bridging Hardware and\u00a0Software</h3>\n<p>Device drivers are specialized modules within the kernel that facilitate communication with hardware components\u200a\u2014\u200asuch as cameras, sensors, and displays. They translate high-level commands into device-specific operations, enabling seamless integration between the software and the physical hardware\u2026</p>\n<p><strong>Analogy</strong><br>Think of device drivers as the car\u2019s onboard control modules and wiring systems. They act like the Electronic Control Units [ECUs] that interpret signals from the accelerator, brakes, and steering wheel to coordinate the car\u2019s mechanical responses. In the same way, drivers translate the kernel\u2019s commands into actions that hardware components can execute, ensuring every part of the car [or device] functions correctly\u2026</p>\n<h3>5. File System Management: Organising Data\u00a0Storage</h3>\n<p>The kernel\u2019s File System Management is tasked with organising, storing, and retrieving data on the device. It maintains the structure of directories and files, manages permissions, and ensures data integrity, allowing for fast and secure access to stored information\u2026</p>\n<p><strong>Analogy</strong><br>Imagine that File System Management is the car\u2019s dashboard and central computer that organises vital information. Just as the dashboard displays organised data [speed, fuel level, engine temperature, etc] and the car\u2019s compartments keep everything neatly stored, the kernel organises files and data so that everything is accessible and well-maintained. It is like having a perfectly organised trunk where every tool and accessory has its designated place\u2026</p>\n<h3>6. Inter-Process Communication &amp; System Calls: The Communication Network</h3>\n<p>Inter-process communication [IPC] and System Calls form the channels through which user applications interact with the kernel. These mechanisms allow apps to request services like file access, process control, or hardware operations, ensuring that the kernel can serve as a reliable intermediary between user commands and system-level actions\u2026</p>\n<p><strong>Analogy</strong><br>Think of IPC and System Calls as the car\u2019s internal wiring and sensor network. When you press the accelerator or turn the steering wheel, signals travel through a network of wires to the Engine Control Unit [ECU], which then adjusts performance accordingly. Similarly, the System Calls act as the direct communication lines between applications and the kernel, ensuring that every command is transmitted accurately\u200a\u2014\u200ajust like the reliable wiring that keeps your car running smoothly\u2026</p>\n<h3>7. Security, Customisation, and Performance: Tuning The\u00a0System</h3>\n<p>The kernel incorporates robust security measures\u200a\u2014\u200asuch as SELinux\u200a\u2014\u200ato enforce permissions and protect the system from unauthorised access. Additionally, its modular design allows for customisation and performance tuning through loadable modules and configurable settings. This flexibility enables Android Engineers to optimise the system for specific hardware or application needs\u2026</p>\n<p><strong>Analogy</strong><br>Imagine this aspect as the car\u2019s advanced safety systems and performance tuning options. The kernel\u2019s security features are like airbags, anti-lock brakes, and alarm systems that protect you on the road. Customisation and performance tuning are similar to upgrading your car\u2019s suspension, engine chip, or even selecting different driving modes [Eco, Sport, and Comfort] to tailor the driving experience. These features ensure that your \u201cvehicle\u201d runs safely, efficiently, and exactly to your preferences\u2026</p>\n<h3>UP NEXT</h3>\n<p>The Hardware Abstraction Layer [HAL]: <a href=\"https://medium.com/@emmanuelmuturia/3dbb6e96cd43\">https://medium.com/@emmanuelmuturia/3dbb6e96cd43</a></p>\n<h3>CONCLUSION</h3>\n<p>Apart from the desire to drive your Car right now, I hope that you have now gotten a better and more technical understanding of The Linux Kernel in the context [pun intended] of The Android Architecture. Stay tuned for more content and until then, I hope that you remember what you learned today each time you go for your road trip\u00a0:)\u2026</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/498/0*IcGouFB37jkyhMqF.gif\"></figure><h3><strong>REFERENCES</strong></h3>\n<p><em>Platform Architecture</em>. (2023, May 4). Android Developers. <a href=\"https://developer.android.com/guide/platform\">https://developer.android.com/guide/platform</a></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=5fd3213d4eb2\" width=\"1\" height=\"1\" alt=\"\">\n","enclosure":{},"categories":["linux-kernel","android","androiddev","linux","android-app-development"]},{"title":"How Not To Write UI Tests [feat. Test Tags &amp; Semantics]","pubDate":"2025-01-21 04:27:21","link":"https://medium.com/@emmanuelmuturia/how-not-to-write-ui-tests-feat-test-tags-semantics-8b7c71e79e70?source=rss-6256c7dbb031------2","guid":"https://medium.com/p/8b7c71e79e70","author":"Emmanuel Muturia\u2122","thumbnail":"","description":"\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*uqSs9KjWQlVjoDeSsgjfzA.png\"></figure><p>I was trying to figure out why my Compose UI Tests were suddenly failing when I stumbled upon this article: <a href=\"https://tomasrepcik.dev/blog/2024/2024-02-13-test-tags-and-sematics/\">https://tomasrepcik.dev/blog/2024/2024-02-13-test-tags-and-sematics/</a></p>\n<h3>BACKGROUND</h3>\n<p>At first, I wondered why Test Tags would not be the best for writing UI Tests in Jetpack Compose. However, reading that article provided me with insights that I had not considered throughout my journey in Testing [and Android in general]. In this article, we are going to learn why Test Tags might not be the best approach to writing and running our Compose UI Tests. If that sounds interesting, then please read on. This is: <strong>How Not To Write UI Tests [feat. Test Tags &amp; Semantics]</strong></p>\n<h3><strong>WHAT ARE TEST\u00a0TAGS?</strong></h3>\n<p>If you are new to Compose UI Tests, then please check out this documentation to gain a decent foundation on the same and then return here to learn about Test Tags in Compose UI Tests: <a href=\"https://developer.android.com/develop/ui/compose/testing\">https://developer.android.com/develop/ui/compose/testing</a></p>\n<p>Welcome back. As I was saying, Test Tags are a common way of conducting Compose UI Tests. Why is that? Well, that is because they are used to uniquely identify a node [Composable that is to be tested]. Think of them as actual name tags in real life that may be used to uniquely identify someone using their name. In the same way, Test Tags are used when we need to test a specific node when writing Compose UI\u00a0Tests\u2026</p>\n<h3><strong>WHAT IS THEIR\u00a0PROBLEM?</strong></h3>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/498/0*aCPvvzJyUdMPBf-s.gif\"></figure><p>Well, it is not really about them having a problem but rather them having certain limitations that make them unsuitable for effectively writing and running Compose UI Tests. Without wasting any time, here are the Test Tag limitations that you should consider when writing Compose UI\u00a0Tests:</p>\n<p><strong>1] Developer-Specific</strong></p>\n<ul>\n<li>\n<strong>Test Tags</strong> are intended only for testing purposes and are invisible to end-users or accessibility tools\u2026</li>\n<li>They need to be manually added by the developer, which can lead to errors if\u00a0missed\u2026</li>\n</ul>\n<p><strong>2] No Built-In Accessibility Support</strong></p>\n<ul><li>\n<strong>Test Tags</strong> do not automatically enhance the accessibility of your app, unlike semantics (e.g., contentDescription), which are designed for screen readers and assistive technologies\u2026</li></ul>\n<p><strong>3] Not Always Attached\u00a0Properly</strong></p>\n<ul><li>Test Tags depend on developers explicitly adding them to Composables. If a developer forgets to set a test tag or assigns it incorrectly, the UI Tests may\u00a0fail\u2026</li></ul>\n<p><strong>4] Ambiguity in Complex\u00a0UIs</strong></p>\n<ul><li>If multiple components share the same testTag, it can cause ambiguity in identifying which component the test should interact with, leading to Flaky\u00a0Tests\u2026</li></ul>\n<p><strong>5] Limited to Testing\u00a0Context</strong></p>\n<ul><li>Test Tags are useful for testing but do not impact the User Experience [UX] directly. They do not improve the app\u2019s usability or accessibility for real\u00a0users\u2026</li></ul>\n<h3><strong>CAN I STILL USE TEST TAGS,\u00a0THOUGH?</strong></h3>\n<p>Why not? While Test Tags have their fair share of limitations, here is where they may come in\u00a0handy:</p>\n<p><strong>1] When Semantics Are Not Suitable for Testing\u00a0Purposes</strong></p>\n<ul>\n<li>\n<strong>Test Tags</strong> are ideal when you need to create test-specific identifiers that are not necessarily related to the <strong>meaning</strong> or <strong>functionality</strong> of the UI element. This is especially useful when you do not want to affect the A<strong>ccessibility</strong> layer of the\u00a0app\u2026</li>\n<li>For instance, if you need to test an internal implementation detail or create a <strong>test-only identifier</strong> that does not need to be read by screen readers, a <strong>Test Tag</strong> is a good option. Here is an\u00a0example:</li>\n</ul>\n<pre>Box(modifier = Modifier.testTag(tag = \"TestTagForSomeElement\")) {<br>    // Your UI content...<br>}</pre>\n<p>In this case, you are providing a tag that serves no accessibility purpose, but simply helps you locate the element in your\u00a0tests\u2026</p>\n<p><strong>2] When Identifying Unique or Complex UI\u00a0Elements</strong></p>\n<ul>\n<li>\n<strong>Test Tags</strong> are useful when dealing with complex UI hierarchies or dynamic lists, where semantic identifiers like contentDescription might not be as clear or suitable\u2026</li>\n<li>If there are multiple similar items (e.g., list items) and the <strong>contentDescription</strong> would be too generic or difficult to differentiate, <strong>Test Tags</strong> can be a more straightforward way to uniquely identify them. Here is an\u00a0example:</li>\n</ul>\n<pre>LazyColumn {<br>    items(items = listOfItems) { item -&gt;<br>        Text(text = \"Item ${item.id}\", modifier = Modifier.testTag(tag = \"Item-${item.id}\"))<br>    }<br>}</pre>\n<p><strong>3] When You Need a Stable Identifier for\u00a0Testing</strong></p>\n<ul>\n<li>\n<strong>Test Tags</strong> are great when you need a stable identifier for UI elements, particularly in <strong>UI tests</strong> where the visual layout may change but the tag remains constant\u2026</li>\n<li>In some cases, <strong>contentDescription</strong> might be tied to the actual text or label of the UI element (which could change), whereas <strong>Test Tags</strong> provide a more stable reference that won\u2019t be impacted by content changes. Here is an\u00a0example:</li>\n</ul>\n<pre>Button(onClick = { /* Do something... */ }, modifier = Modifier.testTag(tag = \"SubmitButton\")) {<br>    Text(text = \"Submit\")<br>}</pre>\n<p>This ensures that your tests won\u2019t break if the button text changes, as long as the <strong>Test Tag</strong> stays the\u00a0same\u2026</p>\n<p><strong>4] When You Need to Perform Tests on Non-Visible UI\u00a0Elements</strong></p>\n<ul>\n<li>If you have <strong>UI elements that are not visible</strong> but are important for testing (such as <strong>invisible buttons</strong>, <strong>hidden fields</strong>, or <strong>invisible states</strong>), Test Tags can be an excellent solution\u2026</li>\n<li>These elements may not need semantic identifiers (like Content Descriptions) because they are not meant to be read by screen readers, but you still need a way to reference them in tests. Here is an\u00a0example:</li>\n</ul>\n<pre>Box(modifier = Modifier.testTag(tag = \"InvisibleElement\").fillMaxSize().alpha(alpha = 0f)) {<br>    // UI content...<br>}</pre>\n<p><strong>5] For Performance and Fine-Tuned Control</strong></p>\n<ul>\n<li>In some performance-sensitive tests, <strong>Test Tags</strong> can provide a lightweight and specific way to interact with UI elements, without the overhead of accessibility descriptions\u2026</li>\n<li>Test Tags provide a fine-tuned level of control over which elements to interact with during testing, especially when targeting elements for automation or when testing <strong>non-visible</strong> content\u2026</li>\n</ul>\n<h3><strong>WHAT ARE SEMANTICS?</strong></h3>\n<p>Alright. We have talked about Test Tags and their limitations in Compose UI Testing. What then, are Semantics? Well, in Jetpack Compose, <strong>Semantics</strong> is a system used to describe the meaning and purpose of UI elements in an app. It is crucial for Accessibility, ensuring that users with disabilities can interact with and navigate the app using assistive technologies like screen readers. Semantics, particularly <strong>contentDescription</strong>, is a key part of this\u00a0system\u2026</p>\n<ul><li>\n<strong>Content Description</strong>: A description that can be added to a UI element (such as an image, button, or icon) to provide a text-based description of what the element does or represents. This text is then read aloud by screen readers for users with visual impairments, making the app more accessible\u2026</li></ul>\n<p>In addition to <strong>contentDescription</strong>, semantics may also include other attributes that describe the element\u2019s state, actions, or labels, such as stateDescription, role, text, and liveRegion\u2026</p>\n<h3><strong>For Example [Semantics]</strong></h3>\n<p>Let us say we have a button that plays a video. In the UI, we add a contentDescription to the button for accessibility purposes:</p>\n<pre>Button(<br>    onClick = { /* Play video... */ },<br>    modifier = Modifier.semantics { contentDescription = \"Play Video Button\" }<br>) {<br>    Text(text = \"Play\")<br>}</pre>\n<p>Now, when we write UI tests, we can locate and interact with this button by referencing its <strong>contentDescription</strong>:</p>\n<pre>@Test<br>fun testPlayButtonExists() {<br>    onNodeWithContentDescription(label = \"Play Video Button\")<br>        .assertExists() // Verifies that the Play Video button exists...<br>}</pre>\n<p>This makes the test <strong>more robust</strong>, since the button\u2019s purpose is clearly described, and the test will reliably work even if other parts of the UI change, as long as the <strong>contentDescription</strong> remains consistent\u2026</p>\n<h3>WHY SHOULD I USE SEMANTICS IN MY COMPOSE UI\u00a0TESTS?</h3>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/498/0*-O35UE6JiEM4NtW9.gif\"></figure><p>Here is why you may be better off using Semantics [Content Description] in your Compose UI\u00a0Tests:</p>\n<p><strong>1] User-Facing and Accessibility-Oriented</strong></p>\n<ul>\n<li>\n<strong>Content Descriptions (Semantics)</strong>, such as contentDescription, are primarily designed to make the app more accessible to users with disabilities (e.g., screen readers)\u2026</li>\n<li>They improve accessibility for real users, not just during\u00a0testing\u2026</li>\n</ul>\n<p><strong>2] Stable and Meaningful</strong></p>\n<ul>\n<li>Unlike Test Tags, which may only serve the purpose of testing, semantics are <strong>naturally meaningful</strong> because they describe the function or content of the UI\u00a0element\u2026</li>\n<li>This makes them inherently more stable for both accessibility and test purposes\u2026</li>\n</ul>\n<p><strong>3] Automatically Attached</strong></p>\n<ul>\n<li>Many <strong>Composables</strong> automatically include useful semantics, such as contentDescription or text, making it easier to test UI elements without extra\u00a0setup\u2026</li>\n<li>They\u2019re tied directly to the component\u2019s behaviour or\u00a0purpose\u2026</li>\n</ul>\n<p><strong>4] Improves Testing and Accessibility</strong></p>\n<ul><li>Using semantics like contentDescription for testing not only improves test reliability but also ensures that the app is <strong>more accessible</strong> to all users, including those using assistive technologies\u2026</li></ul>\n<p><strong>5] Reduces Ambiguity in\u00a0UI</strong></p>\n<ul><li>Semantics typically describe the <strong>purpose</strong> or <strong>content</strong> of UI elements (e.g., a button to play a video), which can be more unique and descriptive than a test tag that may be used across multiple components\u2026</li></ul>\n<h3>THE CONCLUSION</h3>\n<p>By now, you know that Semantics offer a much better experience in Compose UI Testing just as they do in Accessibility. While Test Tags may not be the best solution when writing Compose UI Tests most of the time, they still have their place and you must be diligent enough to when that time is. Now, go forth and upgrade your app\u2019s Testability [and Accessibility], will\u00a0ya?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/640/0*qjVOUwy-BcazwfA5.gif\"></figure><h3>REFERENCES</h3>\n<p><em>Test your Compose layout</em>. (2024). Android Developers. <a href=\"https://developer.android.com/develop/ui/compose/testing\">https://developer.android.com/develop/ui/compose/testing</a></p>\n<p>\u200cTom\u00e1\u0161 Rep\u010d\u00edk. (2024, February). <em>Stop Using Test Tags in the Jetpack Compose Production Code</em>. Tom\u00e1\u0161 Rep\u010d\u00edk\u200a\u2014\u200aBlog. <a href=\"https://tomasrepcik.dev/blog/2024/2024-02-13-test-tags-and-sematics/\">https://tomasrepcik.dev/blog/2024/2024-02-13-test-tags-and-sematics/</a></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=8b7c71e79e70\" width=\"1\" height=\"1\" alt=\"\">\n","content":"\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*uqSs9KjWQlVjoDeSsgjfzA.png\"></figure><p>I was trying to figure out why my Compose UI Tests were suddenly failing when I stumbled upon this article: <a href=\"https://tomasrepcik.dev/blog/2024/2024-02-13-test-tags-and-sematics/\">https://tomasrepcik.dev/blog/2024/2024-02-13-test-tags-and-sematics/</a></p>\n<h3>BACKGROUND</h3>\n<p>At first, I wondered why Test Tags would not be the best for writing UI Tests in Jetpack Compose. However, reading that article provided me with insights that I had not considered throughout my journey in Testing [and Android in general]. In this article, we are going to learn why Test Tags might not be the best approach to writing and running our Compose UI Tests. If that sounds interesting, then please read on. This is: <strong>How Not To Write UI Tests [feat. Test Tags &amp; Semantics]</strong></p>\n<h3><strong>WHAT ARE TEST\u00a0TAGS?</strong></h3>\n<p>If you are new to Compose UI Tests, then please check out this documentation to gain a decent foundation on the same and then return here to learn about Test Tags in Compose UI Tests: <a href=\"https://developer.android.com/develop/ui/compose/testing\">https://developer.android.com/develop/ui/compose/testing</a></p>\n<p>Welcome back. As I was saying, Test Tags are a common way of conducting Compose UI Tests. Why is that? Well, that is because they are used to uniquely identify a node [Composable that is to be tested]. Think of them as actual name tags in real life that may be used to uniquely identify someone using their name. In the same way, Test Tags are used when we need to test a specific node when writing Compose UI\u00a0Tests\u2026</p>\n<h3><strong>WHAT IS THEIR\u00a0PROBLEM?</strong></h3>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/498/0*aCPvvzJyUdMPBf-s.gif\"></figure><p>Well, it is not really about them having a problem but rather them having certain limitations that make them unsuitable for effectively writing and running Compose UI Tests. Without wasting any time, here are the Test Tag limitations that you should consider when writing Compose UI\u00a0Tests:</p>\n<p><strong>1] Developer-Specific</strong></p>\n<ul>\n<li>\n<strong>Test Tags</strong> are intended only for testing purposes and are invisible to end-users or accessibility tools\u2026</li>\n<li>They need to be manually added by the developer, which can lead to errors if\u00a0missed\u2026</li>\n</ul>\n<p><strong>2] No Built-In Accessibility Support</strong></p>\n<ul><li>\n<strong>Test Tags</strong> do not automatically enhance the accessibility of your app, unlike semantics (e.g., contentDescription), which are designed for screen readers and assistive technologies\u2026</li></ul>\n<p><strong>3] Not Always Attached\u00a0Properly</strong></p>\n<ul><li>Test Tags depend on developers explicitly adding them to Composables. If a developer forgets to set a test tag or assigns it incorrectly, the UI Tests may\u00a0fail\u2026</li></ul>\n<p><strong>4] Ambiguity in Complex\u00a0UIs</strong></p>\n<ul><li>If multiple components share the same testTag, it can cause ambiguity in identifying which component the test should interact with, leading to Flaky\u00a0Tests\u2026</li></ul>\n<p><strong>5] Limited to Testing\u00a0Context</strong></p>\n<ul><li>Test Tags are useful for testing but do not impact the User Experience [UX] directly. They do not improve the app\u2019s usability or accessibility for real\u00a0users\u2026</li></ul>\n<h3><strong>CAN I STILL USE TEST TAGS,\u00a0THOUGH?</strong></h3>\n<p>Why not? While Test Tags have their fair share of limitations, here is where they may come in\u00a0handy:</p>\n<p><strong>1] When Semantics Are Not Suitable for Testing\u00a0Purposes</strong></p>\n<ul>\n<li>\n<strong>Test Tags</strong> are ideal when you need to create test-specific identifiers that are not necessarily related to the <strong>meaning</strong> or <strong>functionality</strong> of the UI element. This is especially useful when you do not want to affect the A<strong>ccessibility</strong> layer of the\u00a0app\u2026</li>\n<li>For instance, if you need to test an internal implementation detail or create a <strong>test-only identifier</strong> that does not need to be read by screen readers, a <strong>Test Tag</strong> is a good option. Here is an\u00a0example:</li>\n</ul>\n<pre>Box(modifier = Modifier.testTag(tag = \"TestTagForSomeElement\")) {<br>    // Your UI content...<br>}</pre>\n<p>In this case, you are providing a tag that serves no accessibility purpose, but simply helps you locate the element in your\u00a0tests\u2026</p>\n<p><strong>2] When Identifying Unique or Complex UI\u00a0Elements</strong></p>\n<ul>\n<li>\n<strong>Test Tags</strong> are useful when dealing with complex UI hierarchies or dynamic lists, where semantic identifiers like contentDescription might not be as clear or suitable\u2026</li>\n<li>If there are multiple similar items (e.g., list items) and the <strong>contentDescription</strong> would be too generic or difficult to differentiate, <strong>Test Tags</strong> can be a more straightforward way to uniquely identify them. Here is an\u00a0example:</li>\n</ul>\n<pre>LazyColumn {<br>    items(items = listOfItems) { item -&gt;<br>        Text(text = \"Item ${item.id}\", modifier = Modifier.testTag(tag = \"Item-${item.id}\"))<br>    }<br>}</pre>\n<p><strong>3] When You Need a Stable Identifier for\u00a0Testing</strong></p>\n<ul>\n<li>\n<strong>Test Tags</strong> are great when you need a stable identifier for UI elements, particularly in <strong>UI tests</strong> where the visual layout may change but the tag remains constant\u2026</li>\n<li>In some cases, <strong>contentDescription</strong> might be tied to the actual text or label of the UI element (which could change), whereas <strong>Test Tags</strong> provide a more stable reference that won\u2019t be impacted by content changes. Here is an\u00a0example:</li>\n</ul>\n<pre>Button(onClick = { /* Do something... */ }, modifier = Modifier.testTag(tag = \"SubmitButton\")) {<br>    Text(text = \"Submit\")<br>}</pre>\n<p>This ensures that your tests won\u2019t break if the button text changes, as long as the <strong>Test Tag</strong> stays the\u00a0same\u2026</p>\n<p><strong>4] When You Need to Perform Tests on Non-Visible UI\u00a0Elements</strong></p>\n<ul>\n<li>If you have <strong>UI elements that are not visible</strong> but are important for testing (such as <strong>invisible buttons</strong>, <strong>hidden fields</strong>, or <strong>invisible states</strong>), Test Tags can be an excellent solution\u2026</li>\n<li>These elements may not need semantic identifiers (like Content Descriptions) because they are not meant to be read by screen readers, but you still need a way to reference them in tests. Here is an\u00a0example:</li>\n</ul>\n<pre>Box(modifier = Modifier.testTag(tag = \"InvisibleElement\").fillMaxSize().alpha(alpha = 0f)) {<br>    // UI content...<br>}</pre>\n<p><strong>5] For Performance and Fine-Tuned Control</strong></p>\n<ul>\n<li>In some performance-sensitive tests, <strong>Test Tags</strong> can provide a lightweight and specific way to interact with UI elements, without the overhead of accessibility descriptions\u2026</li>\n<li>Test Tags provide a fine-tuned level of control over which elements to interact with during testing, especially when targeting elements for automation or when testing <strong>non-visible</strong> content\u2026</li>\n</ul>\n<h3><strong>WHAT ARE SEMANTICS?</strong></h3>\n<p>Alright. We have talked about Test Tags and their limitations in Compose UI Testing. What then, are Semantics? Well, in Jetpack Compose, <strong>Semantics</strong> is a system used to describe the meaning and purpose of UI elements in an app. It is crucial for Accessibility, ensuring that users with disabilities can interact with and navigate the app using assistive technologies like screen readers. Semantics, particularly <strong>contentDescription</strong>, is a key part of this\u00a0system\u2026</p>\n<ul><li>\n<strong>Content Description</strong>: A description that can be added to a UI element (such as an image, button, or icon) to provide a text-based description of what the element does or represents. This text is then read aloud by screen readers for users with visual impairments, making the app more accessible\u2026</li></ul>\n<p>In addition to <strong>contentDescription</strong>, semantics may also include other attributes that describe the element\u2019s state, actions, or labels, such as stateDescription, role, text, and liveRegion\u2026</p>\n<h3><strong>For Example [Semantics]</strong></h3>\n<p>Let us say we have a button that plays a video. In the UI, we add a contentDescription to the button for accessibility purposes:</p>\n<pre>Button(<br>    onClick = { /* Play video... */ },<br>    modifier = Modifier.semantics { contentDescription = \"Play Video Button\" }<br>) {<br>    Text(text = \"Play\")<br>}</pre>\n<p>Now, when we write UI tests, we can locate and interact with this button by referencing its <strong>contentDescription</strong>:</p>\n<pre>@Test<br>fun testPlayButtonExists() {<br>    onNodeWithContentDescription(label = \"Play Video Button\")<br>        .assertExists() // Verifies that the Play Video button exists...<br>}</pre>\n<p>This makes the test <strong>more robust</strong>, since the button\u2019s purpose is clearly described, and the test will reliably work even if other parts of the UI change, as long as the <strong>contentDescription</strong> remains consistent\u2026</p>\n<h3>WHY SHOULD I USE SEMANTICS IN MY COMPOSE UI\u00a0TESTS?</h3>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/498/0*-O35UE6JiEM4NtW9.gif\"></figure><p>Here is why you may be better off using Semantics [Content Description] in your Compose UI\u00a0Tests:</p>\n<p><strong>1] User-Facing and Accessibility-Oriented</strong></p>\n<ul>\n<li>\n<strong>Content Descriptions (Semantics)</strong>, such as contentDescription, are primarily designed to make the app more accessible to users with disabilities (e.g., screen readers)\u2026</li>\n<li>They improve accessibility for real users, not just during\u00a0testing\u2026</li>\n</ul>\n<p><strong>2] Stable and Meaningful</strong></p>\n<ul>\n<li>Unlike Test Tags, which may only serve the purpose of testing, semantics are <strong>naturally meaningful</strong> because they describe the function or content of the UI\u00a0element\u2026</li>\n<li>This makes them inherently more stable for both accessibility and test purposes\u2026</li>\n</ul>\n<p><strong>3] Automatically Attached</strong></p>\n<ul>\n<li>Many <strong>Composables</strong> automatically include useful semantics, such as contentDescription or text, making it easier to test UI elements without extra\u00a0setup\u2026</li>\n<li>They\u2019re tied directly to the component\u2019s behaviour or\u00a0purpose\u2026</li>\n</ul>\n<p><strong>4] Improves Testing and Accessibility</strong></p>\n<ul><li>Using semantics like contentDescription for testing not only improves test reliability but also ensures that the app is <strong>more accessible</strong> to all users, including those using assistive technologies\u2026</li></ul>\n<p><strong>5] Reduces Ambiguity in\u00a0UI</strong></p>\n<ul><li>Semantics typically describe the <strong>purpose</strong> or <strong>content</strong> of UI elements (e.g., a button to play a video), which can be more unique and descriptive than a test tag that may be used across multiple components\u2026</li></ul>\n<h3>THE CONCLUSION</h3>\n<p>By now, you know that Semantics offer a much better experience in Compose UI Testing just as they do in Accessibility. While Test Tags may not be the best solution when writing Compose UI Tests most of the time, they still have their place and you must be diligent enough to when that time is. Now, go forth and upgrade your app\u2019s Testability [and Accessibility], will\u00a0ya?</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/640/0*qjVOUwy-BcazwfA5.gif\"></figure><h3>REFERENCES</h3>\n<p><em>Test your Compose layout</em>. (2024). Android Developers. <a href=\"https://developer.android.com/develop/ui/compose/testing\">https://developer.android.com/develop/ui/compose/testing</a></p>\n<p>\u200cTom\u00e1\u0161 Rep\u010d\u00edk. (2024, February). <em>Stop Using Test Tags in the Jetpack Compose Production Code</em>. Tom\u00e1\u0161 Rep\u010d\u00edk\u200a\u2014\u200aBlog. <a href=\"https://tomasrepcik.dev/blog/2024/2024-02-13-test-tags-and-sematics/\">https://tomasrepcik.dev/blog/2024/2024-02-13-test-tags-and-sematics/</a></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=8b7c71e79e70\" width=\"1\" height=\"1\" alt=\"\">\n","enclosure":{},"categories":["jetpack-compose","android-app-development","kotlin","ui-testing","accessibility"]},{"title":"The Kotlin Coroutine Job Lifecycle","pubDate":"2024-11-26 04:02:15","link":"https://medium.com/@emmanuelmuturia/the-kotlin-coroutine-job-lifecycle-e695c1e93bb0?source=rss-6256c7dbb031------2","guid":"https://medium.com/p/e695c1e93bb0","author":"Emmanuel Muturia\u2122","thumbnail":"","description":"\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/800/1*5T-TiUn9WzB1340x51DM1g.png\"><figcaption>Keep reading to learn\u00a0more\u2026</figcaption></figure><p>If you have been building for Android using Kotlin, then you know that it is almost impossible to run away from Kotlin Coroutines. If you have been reading my articles [as you should\u00a0:)], then you know how much I love using them and why you should too. In this article, you are going to gain a deeper knowledge of The Kotlin Coroutine Job Lifecycle to understand Kotlin Coroutines better and use them more efficiently to build your billion-dollar Android apps. This is: <strong>The Kotlin Coroutine Job Lifecycle</strong>\u2026</p>\n<h3><strong>THE BACKGROUND</strong></h3>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/220/0*Du1WNph_y-DE5qvt.gif\"></figure><p>Hold on. Did you just say that you have no idea what a Kotlin Coroutine Job is? Do not worry for this is exactly why I want to first give you some context [these puns are just too much] on what they are and why you should even be knowing them. I promise you though, that Kotlin Coroutine Jobs are not the kind that involve clocking in from 09:00 to 17:00. They are much better and so good that you cannot ignore them. Did you see what I did there? Anyway, <strong>what are Kotlin Coroutine Jobs?</strong></p>\n<h3><strong>WHAT ARE KOTLIN COROUTINE JOBS?</strong></h3>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/220/0*_xeQ9jFg7d8Hk_1D.gif\"></figure><p>Here is the definition of a Kotlin Coroutine Job according to the official Kotlin documentation:</p>\n<p><strong><em>\u201cA background job. Conceptually, a job is a cancellable thing with a life-cycle that culminates in its completion.\u201d </em></strong>~\u00a0Kotlin</p>\n<p>I can already tell that some of you are already panicking but you know that I would not leave out an analogy to drive the point home like your dream German Machine. Here is an analogy to help you understand what a Kotlin Coroutine Job\u00a0is:</p>\n<p>A <strong>Kotlin Coroutine Job</strong> is like the <strong>event manager</strong> of a workplace tasked with hosting a company event. It oversees the entire process, tracking progress and ensuring tasks are executed correctly. This makes the <strong>Job</strong> responsible for managing the lifecycle and state of a coroutine or a group of coroutines.</p>\n<p>The <strong>Job is lifecycle-aware</strong>, meaning it transitions through states such as <strong>New</strong> (just created but not started), <strong>Active</strong> (currently executing tasks), <strong>Completing</strong> (wrapping up its work), and <strong>Completed</strong> (fully done). It ensures that tasks are carried out in an organised manner and can handle interruptions gracefully.</p>\n<p>If the <strong>Job is cancelled</strong>, it behaves like an event manager halting all teams (Child Coroutines) under their supervision. The cancellation propagates downwards, ensuring no dangling tasks remain. This hierarchical control makes <strong>Job cancellation efficient and reliable</strong>, maintaining <strong>Structured Concurrency</strong>.</p>\n<p>Finally, the <strong>Job allows direct control</strong> over coroutine execution. You can call job.cancel() to immediately stop the associated work, or use job.join() to wait for it to finish. It also ensures resource cleanup if tasks are interrupted, much like an event manager handling unforeseen issues while closing down an\u00a0event.</p>\n<p>In essence, a <strong>Kotlin Coroutine Job acts as a supervisor and tracker</strong>, ensuring coroutines are managed efficiently, their progress is tracked, and their termination is handled properly when required.</p>\n<p><strong>NB: </strong>I have already mentioned The Kotlin Coroutine Job Lifecycle\u2019s stages but I am going to conduct a deep dive on them so do not stress if you do not know them\u00a0yet\u2026</p>\n<h3><strong>THE STAGES</strong></h3>\n<p>Now that you know what a Kotlin Coroutine Job is, you are ready to learn the Kotlin Coroutine Job Lifecycle. I promise you that it is simpler than you think so keep scrolling to discover the secrets of a Kotlin Coroutine Job\u2026</p>\n<p>Here is a rundown of The Kotlin Coroutine Job Lifecycle using an analogy since I know that you love them so much that I cannot afford to include\u00a0them:</p>\n<h3>1. New (The Script is\u00a0Written)</h3>\n<p>In this stage, the coroutine is <strong>created but not started</strong>. Think of this as when a <strong>script for a play is written</strong>, and the stage is set, but no actors have been called to perform yet. The Job is merely an idea waiting to be brought to life. At this point, no resources are being used, and no work has begun. This is the starting state of a Coroutine.</p>\n<p><strong>Key Detail:</strong> The Coroutine exists but remains idle until explicitly started.</p>\n<h3>2. Active (The Play is Performed)</h3>\n<p>When the Coroutine is started, it moves into the <strong>Active</strong> state, just like when the <strong>actors take the stage and start performing the play</strong>. The Job is now running, executing tasks, and using resources. This is the main phase where the Coroutine performs its work, processing instructions and potentially interacting with other coroutines.</p>\n<p><strong>Key Detail:</strong> The Coroutine continues in this state unless it completes its work or encounters cancellation.</p>\n<h3>3. Completing (The Curtain\u00a0Falls)</h3>\n<p>Once the work of the Coroutine is done or all actors have finished their lines, the Coroutine enters the <strong>Completing</strong> state. This is like when the <strong>curtain falls after the play</strong>, but backstage cleanup is still ongoing. The Job ensures that all necessary cleanup (like releasing resources or notifying dependents) is completed before moving to the final\u00a0state.</p>\n<p><strong>Key Detail:</strong> This state ensures that the Coroutine wraps up cleanly, regardless of how it finishes (successfully or due to an\u00a0error).</p>\n<h3>4. Completed (The Theatre is\u00a0Empty)</h3>\n<p>When all the cleanup is finished, and no more tasks are left, the Coroutine enters the <strong>Completed</strong> state. This is akin to when the <strong>theatre is empty, and everyone has gone home</strong>. The Job is fully done, and its results (or exceptions) are available for review. If the Coroutine encounters an error, this is also when the exception is propagated.</p>\n<p><strong>Key Detail:</strong> This is the terminal state of the Coroutine. Once in this state, the Job cannot be restarted.</p>\n<h3>5. Cancelled (The Play is Interrupted Mid-Performance)</h3>\n<p>If the Job is cancelled while it is active, it transitions to the <strong>Cancelled</strong> state. This is like when the <strong>play is stopped halfway through due to an emergency</strong>. The actors leave the stage, the lights go off, and everything comes to a halt. Any remaining tasks are abandoned, and the Job makes sure that cleanup is performed to prevent resource\u00a0leaks.</p>\n<p><strong>Key Detail:</strong> Cancellation propagates down to Child Coroutines, ensuring no part of the play continues if it has been interrupted.</p>\n<p>In summary, the <strong>Kotlin Coroutine Job lifecycle</strong> is like the <strong>journey of a play</strong>, from writing the script to wrapping up after the performance. Each stage ensures a well-defined flow of actions, resources, and outcomes, providing clear control over coroutine execution and its eventual termination\u2026</p>\n<h3><strong>A WORD FROM THE OFFICIAL KOTLIN DOCUMENTATION</strong></h3>\n<p>You might be wondering how The Kotlin Coroutine Job Lifecycle flows from a holistic perspective. To make that easier for you, here is a summary of how the entire lifecycle flows based on the official Kotlin documentation:</p>\n<pre>wait children<br>    +-----+ start  +--------+ complete   +-------------+  finish  +-----------+<br>    | New | -----&gt; | Active | ---------&gt; | Completing  | -------&gt; | Completed |<br>    +-----+        +--------+            +-------------+          +-----------+<br>                     |  cancel / fail       |<br>                     |     +----------------+<br>                     |     |<br>                     V     V<br>                 +------------+                           finish  +-----------+<br>                 | Cancelling | --------------------------------&gt; | Cancelled |<br>                 +------------+                                   +-----------+</pre>\n<h3><strong>THE CONCLUSION</strong></h3>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/220/0*5ScFX5cBob9oz2lP.gif\"></figure><p>First of all, congratulations on getting to this point. Give yourself a pat on the back, will you? You have learnt about The Kotlin Coroutine Job Lifecycle and the intricacies that go into it. Since you have understood it better, you now bear the responsibility of utilising your Kotlin Coroutines in a much better way than you have been. Remember, <strong>\u201cwith great power comes great responsibility\u2026\u201d</strong>. Go forth and through the knowledge that you now wield, build higher-quality Android apps and make your Kotlin Coroutines proud of you. Stay tuned for the next\u00a0episode\u2026</p>\n<h3><strong>THE REFERENCES</strong></h3>\n<p><em>Job</em>. (2024). Kotlin Help. <a href=\"https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/\">https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/</a></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=e695c1e93bb0\" width=\"1\" height=\"1\" alt=\"\">\n","content":"\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/800/1*5T-TiUn9WzB1340x51DM1g.png\"><figcaption>Keep reading to learn\u00a0more\u2026</figcaption></figure><p>If you have been building for Android using Kotlin, then you know that it is almost impossible to run away from Kotlin Coroutines. If you have been reading my articles [as you should\u00a0:)], then you know how much I love using them and why you should too. In this article, you are going to gain a deeper knowledge of The Kotlin Coroutine Job Lifecycle to understand Kotlin Coroutines better and use them more efficiently to build your billion-dollar Android apps. This is: <strong>The Kotlin Coroutine Job Lifecycle</strong>\u2026</p>\n<h3><strong>THE BACKGROUND</strong></h3>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/220/0*Du1WNph_y-DE5qvt.gif\"></figure><p>Hold on. Did you just say that you have no idea what a Kotlin Coroutine Job is? Do not worry for this is exactly why I want to first give you some context [these puns are just too much] on what they are and why you should even be knowing them. I promise you though, that Kotlin Coroutine Jobs are not the kind that involve clocking in from 09:00 to 17:00. They are much better and so good that you cannot ignore them. Did you see what I did there? Anyway, <strong>what are Kotlin Coroutine Jobs?</strong></p>\n<h3><strong>WHAT ARE KOTLIN COROUTINE JOBS?</strong></h3>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/220/0*_xeQ9jFg7d8Hk_1D.gif\"></figure><p>Here is the definition of a Kotlin Coroutine Job according to the official Kotlin documentation:</p>\n<p><strong><em>\u201cA background job. Conceptually, a job is a cancellable thing with a life-cycle that culminates in its completion.\u201d </em></strong>~\u00a0Kotlin</p>\n<p>I can already tell that some of you are already panicking but you know that I would not leave out an analogy to drive the point home like your dream German Machine. Here is an analogy to help you understand what a Kotlin Coroutine Job\u00a0is:</p>\n<p>A <strong>Kotlin Coroutine Job</strong> is like the <strong>event manager</strong> of a workplace tasked with hosting a company event. It oversees the entire process, tracking progress and ensuring tasks are executed correctly. This makes the <strong>Job</strong> responsible for managing the lifecycle and state of a coroutine or a group of coroutines.</p>\n<p>The <strong>Job is lifecycle-aware</strong>, meaning it transitions through states such as <strong>New</strong> (just created but not started), <strong>Active</strong> (currently executing tasks), <strong>Completing</strong> (wrapping up its work), and <strong>Completed</strong> (fully done). It ensures that tasks are carried out in an organised manner and can handle interruptions gracefully.</p>\n<p>If the <strong>Job is cancelled</strong>, it behaves like an event manager halting all teams (Child Coroutines) under their supervision. The cancellation propagates downwards, ensuring no dangling tasks remain. This hierarchical control makes <strong>Job cancellation efficient and reliable</strong>, maintaining <strong>Structured Concurrency</strong>.</p>\n<p>Finally, the <strong>Job allows direct control</strong> over coroutine execution. You can call job.cancel() to immediately stop the associated work, or use job.join() to wait for it to finish. It also ensures resource cleanup if tasks are interrupted, much like an event manager handling unforeseen issues while closing down an\u00a0event.</p>\n<p>In essence, a <strong>Kotlin Coroutine Job acts as a supervisor and tracker</strong>, ensuring coroutines are managed efficiently, their progress is tracked, and their termination is handled properly when required.</p>\n<p><strong>NB: </strong>I have already mentioned The Kotlin Coroutine Job Lifecycle\u2019s stages but I am going to conduct a deep dive on them so do not stress if you do not know them\u00a0yet\u2026</p>\n<h3><strong>THE STAGES</strong></h3>\n<p>Now that you know what a Kotlin Coroutine Job is, you are ready to learn the Kotlin Coroutine Job Lifecycle. I promise you that it is simpler than you think so keep scrolling to discover the secrets of a Kotlin Coroutine Job\u2026</p>\n<p>Here is a rundown of The Kotlin Coroutine Job Lifecycle using an analogy since I know that you love them so much that I cannot afford to include\u00a0them:</p>\n<h3>1. New (The Script is\u00a0Written)</h3>\n<p>In this stage, the coroutine is <strong>created but not started</strong>. Think of this as when a <strong>script for a play is written</strong>, and the stage is set, but no actors have been called to perform yet. The Job is merely an idea waiting to be brought to life. At this point, no resources are being used, and no work has begun. This is the starting state of a Coroutine.</p>\n<p><strong>Key Detail:</strong> The Coroutine exists but remains idle until explicitly started.</p>\n<h3>2. Active (The Play is Performed)</h3>\n<p>When the Coroutine is started, it moves into the <strong>Active</strong> state, just like when the <strong>actors take the stage and start performing the play</strong>. The Job is now running, executing tasks, and using resources. This is the main phase where the Coroutine performs its work, processing instructions and potentially interacting with other coroutines.</p>\n<p><strong>Key Detail:</strong> The Coroutine continues in this state unless it completes its work or encounters cancellation.</p>\n<h3>3. Completing (The Curtain\u00a0Falls)</h3>\n<p>Once the work of the Coroutine is done or all actors have finished their lines, the Coroutine enters the <strong>Completing</strong> state. This is like when the <strong>curtain falls after the play</strong>, but backstage cleanup is still ongoing. The Job ensures that all necessary cleanup (like releasing resources or notifying dependents) is completed before moving to the final\u00a0state.</p>\n<p><strong>Key Detail:</strong> This state ensures that the Coroutine wraps up cleanly, regardless of how it finishes (successfully or due to an\u00a0error).</p>\n<h3>4. Completed (The Theatre is\u00a0Empty)</h3>\n<p>When all the cleanup is finished, and no more tasks are left, the Coroutine enters the <strong>Completed</strong> state. This is akin to when the <strong>theatre is empty, and everyone has gone home</strong>. The Job is fully done, and its results (or exceptions) are available for review. If the Coroutine encounters an error, this is also when the exception is propagated.</p>\n<p><strong>Key Detail:</strong> This is the terminal state of the Coroutine. Once in this state, the Job cannot be restarted.</p>\n<h3>5. Cancelled (The Play is Interrupted Mid-Performance)</h3>\n<p>If the Job is cancelled while it is active, it transitions to the <strong>Cancelled</strong> state. This is like when the <strong>play is stopped halfway through due to an emergency</strong>. The actors leave the stage, the lights go off, and everything comes to a halt. Any remaining tasks are abandoned, and the Job makes sure that cleanup is performed to prevent resource\u00a0leaks.</p>\n<p><strong>Key Detail:</strong> Cancellation propagates down to Child Coroutines, ensuring no part of the play continues if it has been interrupted.</p>\n<p>In summary, the <strong>Kotlin Coroutine Job lifecycle</strong> is like the <strong>journey of a play</strong>, from writing the script to wrapping up after the performance. Each stage ensures a well-defined flow of actions, resources, and outcomes, providing clear control over coroutine execution and its eventual termination\u2026</p>\n<h3><strong>A WORD FROM THE OFFICIAL KOTLIN DOCUMENTATION</strong></h3>\n<p>You might be wondering how The Kotlin Coroutine Job Lifecycle flows from a holistic perspective. To make that easier for you, here is a summary of how the entire lifecycle flows based on the official Kotlin documentation:</p>\n<pre>wait children<br>    +-----+ start  +--------+ complete   +-------------+  finish  +-----------+<br>    | New | -----&gt; | Active | ---------&gt; | Completing  | -------&gt; | Completed |<br>    +-----+        +--------+            +-------------+          +-----------+<br>                     |  cancel / fail       |<br>                     |     +----------------+<br>                     |     |<br>                     V     V<br>                 +------------+                           finish  +-----------+<br>                 | Cancelling | --------------------------------&gt; | Cancelled |<br>                 +------------+                                   +-----------+</pre>\n<h3><strong>THE CONCLUSION</strong></h3>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/220/0*5ScFX5cBob9oz2lP.gif\"></figure><p>First of all, congratulations on getting to this point. Give yourself a pat on the back, will you? You have learnt about The Kotlin Coroutine Job Lifecycle and the intricacies that go into it. Since you have understood it better, you now bear the responsibility of utilising your Kotlin Coroutines in a much better way than you have been. Remember, <strong>\u201cwith great power comes great responsibility\u2026\u201d</strong>. Go forth and through the knowledge that you now wield, build higher-quality Android apps and make your Kotlin Coroutines proud of you. Stay tuned for the next\u00a0episode\u2026</p>\n<h3><strong>THE REFERENCES</strong></h3>\n<p><em>Job</em>. (2024). Kotlin Help. <a href=\"https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/\">https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/</a></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=e695c1e93bb0\" width=\"1\" height=\"1\" alt=\"\">\n","enclosure":{},"categories":["android-app-development","kotlin-coroutines","kotlin","androiddev","coroutines-in-kotlin"]},{"title":"flowOn {} vs withContext {}","pubDate":"2024-11-19 07:57:55","link":"https://medium.com/@emmanuelmuturia/flow-on-vs-with-context-c6ea088ae90a?source=rss-6256c7dbb031------2","guid":"https://medium.com/p/c6ea088ae90a","author":"Emmanuel Muturia\u2122","thumbnail":"","description":"\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*y81Ckl3tnukq3XJrliF6hg.png\"></figure><p>As a Kotlin lover, you are destined to appreciate how helpful Kotlin Coroutines are in Performance and Efficiency. DSA enthusiasts you can calm down for this is not a LeetCode Q and A but rather a deep dive into the differences between 2 operators that you are likely to come across and use but not fully understand when to apply either specifically. These operators are <strong>flowOn {} </strong>and <strong>withContext {}</strong>\u2026</p>\n<h3>THE BACKGROUND</h3>\n<p>I made an X post some time ago on this topic but was not able to cover much. Here is a snippet of the\u00a0post:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/587/1*pNzMk--0cn1YxWO4QW_UDQ.png\"></figure><p>Here is the link to that post: <a href=\"https://x.com/emmanuelmuturia/status/1818353422292467824\">https://x.com/emmanuelmuturia/status/1818353422292467824</a></p>\n<p>This article seeks to provide more detail on the same topic. With that out of the way, let us figure out why we are focusing specifically on these 2 operators:</p>\n<h3>WHY THESE TWO OPERATORS?</h3>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/400/0*OvzjtpWKXWLyMTg8.gif\"></figure><p>I am glad you asked. You are a quick student, are you not? Anyway, both flowOn {}and withContext {}are used to specify the Context [not the Android one] where the Flow on which it is applied is executed. Simply put, they are used when you want to manually modify the Dispatchers, etc on which the Flow you are operating is executed. For example, if you want the Flow to be executed on Dispatchers.MAIN or whatever other Dispatcher, these 2 operators are your go-to tools. With that out of the way, let us do a bit of a deeper dive into each of them. Let us make it more fun by using an analogy. If that sounds good to you, then keep scrolling as we uncover the secrets behind each of these 2 operators:</p>\n<h3>THE ANALOGY</h3>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/220/0*GyXa1dhFSKtkpQaw.gif\"></figure><p>Imagine you\u2019re working in a bustling kitchen. You have different stations: the prep station, the cooking station, and the plating station. Each station has its staff specialised for the tasks at that\u00a0station\u2026</p>\n<h3>withContext {}</h3>\n<p>withContext {} is like temporarily borrowing a chef from one station to work at another station. For instance, you might have a chef from the prep station come over to help with plating for a few minutes. They do their task at the plating station and then return to their original prep station. This is useful when you need to do a specific task on a different \"thread\" or \"station\" without affecting the overall workflow at that\u00a0station\u2026</p>\n<p><strong>The Code</strong></p>\n<pre>withContext(Dispatchers.IO) {<br>    // Do some background I/O operations here<br>}</pre>\n<p>This snippet temporarily switches the execution context to Dispatchers.IO for the operations inside the block, then returns to the original context once\u00a0done\u2026</p>\n<h3>flowOn {}</h3>\n<p>flowOn {} is like permanently assigning a new chef to a different station for a specific task. Imagine you have a chef dedicated to prepping vegetables. You decide that for all vegetable prep tasks, this chef will always work at the prep station, regardless of where the other tasks in the workflow are happening. This allows you to define the context for a particular part of the workflow, and it stays consistent for that\u00a0part\u2026</p>\n<p><strong>The Code</strong></p>\n<pre>flow {<br>    // Emit some values<br>}<br>.flowOn(Dispatchers.IO)</pre>\n<p>This snippet ensures that all emissions and intermediate operators before flowOn run on Dispatchers.IO. It changes the execution context of the upstream flow, making sure that all operations before flowOn are performed on the specified dispatcher\u2026</p>\n<h3>WHAT ARE THE DIFFERENCES, THEN?</h3>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/220/0*EhH-fIRp7GKG2snF.gif\"></figure><p>Now that we have understood what flowOn {} and withContext {} are all about, here are the key differences between the\u00a02:</p>\n<ol><li><strong>Scope and\u00a0Duration</strong></li></ol>\n<ul>\n<li>withContext {}: Temporary switch of context for the duration of the block. It's like borrowing a chef for a specific\u00a0task\u2026</li>\n<li>flowOn {}: Permanent switch of context for the part of the flow upstream of the flowOn. It's like assigning a chef to a station for a particular type of\u00a0task\u2026</li>\n</ul>\n<p><strong>2. Use\u00a0Case</strong></p>\n<ul>\n<li>withContext {}: Use when you have a blocking task that you want to execute in a different context without affecting the entire\u00a0flow\u2026</li>\n<li>flowOn {}: Use when you want to change the context for the entire upstream operations in a flow, ensuring that all emissions and intermediate steps happen on a specific dispatcher\u2026</li>\n</ul>\n<h3><strong>THE CONCLUSION</strong></h3>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/220/0*RB8ECBSIbD15nOh4.gif\"></figure><ul>\n<li>withContext {} is for temporary context switches for specific\u00a0tasks\u2026</li>\n<li>flowOn {} is for changing the context of the flow's upstream operations consistently\u2026</li>\n</ul>\n<p>That is it for today\u2019s episode. Go forth and become the best Coroutine Context Manager you can be with the knowledge that you have gained. Stay\u00a0tuned\u2026</p>\n<h3>THE REFERENCES</h3>\n<p><em>flowOn</em>. (2024). Kotlinlang.org. <a href=\"https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flow-on.html\">https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flow-on.html</a></p>\n<p>\u200c<em>withContext</em>. (n.d.). Kotlinlang.org. <a href=\"https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-context.html\">https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-context.html</a></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=c6ea088ae90a\" width=\"1\" height=\"1\" alt=\"\">\n","content":"\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*y81Ckl3tnukq3XJrliF6hg.png\"></figure><p>As a Kotlin lover, you are destined to appreciate how helpful Kotlin Coroutines are in Performance and Efficiency. DSA enthusiasts you can calm down for this is not a LeetCode Q and A but rather a deep dive into the differences between 2 operators that you are likely to come across and use but not fully understand when to apply either specifically. These operators are <strong>flowOn {} </strong>and <strong>withContext {}</strong>\u2026</p>\n<h3>THE BACKGROUND</h3>\n<p>I made an X post some time ago on this topic but was not able to cover much. Here is a snippet of the\u00a0post:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/587/1*pNzMk--0cn1YxWO4QW_UDQ.png\"></figure><p>Here is the link to that post: <a href=\"https://x.com/emmanuelmuturia/status/1818353422292467824\">https://x.com/emmanuelmuturia/status/1818353422292467824</a></p>\n<p>This article seeks to provide more detail on the same topic. With that out of the way, let us figure out why we are focusing specifically on these 2 operators:</p>\n<h3>WHY THESE TWO OPERATORS?</h3>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/400/0*OvzjtpWKXWLyMTg8.gif\"></figure><p>I am glad you asked. You are a quick student, are you not? Anyway, both flowOn {}and withContext {}are used to specify the Context [not the Android one] where the Flow on which it is applied is executed. Simply put, they are used when you want to manually modify the Dispatchers, etc on which the Flow you are operating is executed. For example, if you want the Flow to be executed on Dispatchers.MAIN or whatever other Dispatcher, these 2 operators are your go-to tools. With that out of the way, let us do a bit of a deeper dive into each of them. Let us make it more fun by using an analogy. If that sounds good to you, then keep scrolling as we uncover the secrets behind each of these 2 operators:</p>\n<h3>THE ANALOGY</h3>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/220/0*GyXa1dhFSKtkpQaw.gif\"></figure><p>Imagine you\u2019re working in a bustling kitchen. You have different stations: the prep station, the cooking station, and the plating station. Each station has its staff specialised for the tasks at that\u00a0station\u2026</p>\n<h3>withContext {}</h3>\n<p>withContext {} is like temporarily borrowing a chef from one station to work at another station. For instance, you might have a chef from the prep station come over to help with plating for a few minutes. They do their task at the plating station and then return to their original prep station. This is useful when you need to do a specific task on a different \"thread\" or \"station\" without affecting the overall workflow at that\u00a0station\u2026</p>\n<p><strong>The Code</strong></p>\n<pre>withContext(Dispatchers.IO) {<br>    // Do some background I/O operations here<br>}</pre>\n<p>This snippet temporarily switches the execution context to Dispatchers.IO for the operations inside the block, then returns to the original context once\u00a0done\u2026</p>\n<h3>flowOn {}</h3>\n<p>flowOn {} is like permanently assigning a new chef to a different station for a specific task. Imagine you have a chef dedicated to prepping vegetables. You decide that for all vegetable prep tasks, this chef will always work at the prep station, regardless of where the other tasks in the workflow are happening. This allows you to define the context for a particular part of the workflow, and it stays consistent for that\u00a0part\u2026</p>\n<p><strong>The Code</strong></p>\n<pre>flow {<br>    // Emit some values<br>}<br>.flowOn(Dispatchers.IO)</pre>\n<p>This snippet ensures that all emissions and intermediate operators before flowOn run on Dispatchers.IO. It changes the execution context of the upstream flow, making sure that all operations before flowOn are performed on the specified dispatcher\u2026</p>\n<h3>WHAT ARE THE DIFFERENCES, THEN?</h3>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/220/0*EhH-fIRp7GKG2snF.gif\"></figure><p>Now that we have understood what flowOn {} and withContext {} are all about, here are the key differences between the\u00a02:</p>\n<ol><li><strong>Scope and\u00a0Duration</strong></li></ol>\n<ul>\n<li>withContext {}: Temporary switch of context for the duration of the block. It's like borrowing a chef for a specific\u00a0task\u2026</li>\n<li>flowOn {}: Permanent switch of context for the part of the flow upstream of the flowOn. It's like assigning a chef to a station for a particular type of\u00a0task\u2026</li>\n</ul>\n<p><strong>2. Use\u00a0Case</strong></p>\n<ul>\n<li>withContext {}: Use when you have a blocking task that you want to execute in a different context without affecting the entire\u00a0flow\u2026</li>\n<li>flowOn {}: Use when you want to change the context for the entire upstream operations in a flow, ensuring that all emissions and intermediate steps happen on a specific dispatcher\u2026</li>\n</ul>\n<h3><strong>THE CONCLUSION</strong></h3>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/220/0*RB8ECBSIbD15nOh4.gif\"></figure><ul>\n<li>withContext {} is for temporary context switches for specific\u00a0tasks\u2026</li>\n<li>flowOn {} is for changing the context of the flow's upstream operations consistently\u2026</li>\n</ul>\n<p>That is it for today\u2019s episode. Go forth and become the best Coroutine Context Manager you can be with the knowledge that you have gained. Stay\u00a0tuned\u2026</p>\n<h3>THE REFERENCES</h3>\n<p><em>flowOn</em>. (2024). Kotlinlang.org. <a href=\"https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flow-on.html\">https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flow-on.html</a></p>\n<p>\u200c<em>withContext</em>. (n.d.). Kotlinlang.org. <a href=\"https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-context.html\">https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-context.html</a></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=c6ea088ae90a\" width=\"1\" height=\"1\" alt=\"\">\n","enclosure":{},"categories":["kotlin-flow","androiddev","android-app-development","kotlin","kotlin-coroutines"]},{"title":"How To Add Reverb To Your Android App","pubDate":"2024-11-14 05:25:47","link":"https://medium.com/@emmanuelmuturia/how-to-add-reverb-to-your-android-app-7907d0a98367?source=rss-6256c7dbb031------2","guid":"https://medium.com/p/7907d0a98367","author":"Emmanuel Muturia\u2122","thumbnail":"","description":"\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*7fLrxHQIHYavRtYqRiv4OQ.png\"></figure><p>If you are a sane human being, then you are a Music lover. Why would you not be when Music has everything to give and nothing to take away from you besides your stress and other ailments? Anyway, let us cut to the chase and figure out how Music intersects with Android. I am sure you are already thinking about Spotify, Soundcloud, Shazam, and all other Android apps that are centred around Music. However, what if I told you that what I am about to show you will give you more control over Music in your apps that transcends just playing the Music? Sounds good, right? (Pun totally intended\u2026) With that said, here is <strong>How To Add Reverb To Your Android\u00a0App:</strong></p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/498/0*azB5nHVfJjRLkp1k.gif\"></figure><h3>WHAT IS\u00a0REVERB?</h3>\n<p>If you are a fan of not just Music but Music Production, then you are likely to have been introduced and are well-acquainted with the word <strong>Reverb</strong>. You know that Music Producers always swear by using it in their work to make their art sound better in our ears, don\u2019t you? What is Reverb, though for those who may not be familiar with it? (I am sure you have heard its effect even if you may technically not know\u00a0it\u2026)</p>\n<p><strong>Reverb </strong>is an audio effect where sound is simulated to bounce off different kinds of surfaces which produces a special kind of echo that enriches that sound as perceived by the human\u00a0ear.</p>\n<p>This sounds technical but I can assure you that it is such a common phenomenon that you will be glad that you finally found a name for whatever effect you have been hearing in your favourite musical\u00a0pieces.</p>\n<p>Here is a quick video to demonstrate to you what Reverb sounds\u00a0like:</p>\n<a href=\"https://medium.com/media/4389c8818e8edcaba5b5e6c0618052ce/href\">https://medium.com/media/4389c8818e8edcaba5b5e6c0618052ce/href</a><p>As you have just seen (or watched/listened to be more specific), Reverb has different presets (this just means <strong>types</strong> or <strong>flavours</strong>) which can be used depending on what you want your audio to sound\u00a0like.</p>\n<h3>HOW DOES REVERB COME INTO\u00a0ANDROID?</h3>\n<p>Suppose you are building an Android app that plays audio and should allow its users to customise their audio files depending on their preferences (not SharedPreferences). You want to allow them to tweak different settings and audio effects, Reverb being one of them. How do you do this? Drum rolls,\u00a0please\u2026</p>\n<p><strong>EnvironmentalReverb </strong>and <strong>PresetReverb</strong>.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/220/0*4QnDoW8RkPc4pUHu.gif\"></figure><h3>WHAT IS \u201cENVIRONMENTALREVERB\u201d AND \u201cPRESETREVERB\u201d</h3>\n<p>These are both classes from the android.media.audiofx package and are used to customise the Reverb of your\u00a0audio.</p>\n<p>I already know that you are probably asking yourself why we have 2 classes and not just 1 so let me tell you\u00a0why:</p>\n<h3><strong>PresetReverb</strong></h3>\n<p>PresetReverb is a class that provides basic Reverb presets which are PRESET_LARGEHALL\u00a0, PRESET_LARGEROOM\u00a0, PRESET_MEDIUMHALL\u00a0, PRESET_MEDIUMROOM\u00a0, PRESET_SMALLROOM\u00a0, PRESET_PLATE\u00a0, and PRESET_NONE\u00a0. As you can already tell, it is easier for an Android Developer to quickly figure out which preset suits their Android apps just by their names. This means that PresetReverb is suited for adding basic Reverb to the audio files in your Android\u00a0app.</p>\n<h3>EnvironmentalReverb</h3>\n<p>EnvironmentalReverb on the other hand, is a class that provides more flexibility and customisation. How does it achieve this? Well, remember how PresetReverb simply had presets that could be used to enable a particular type of Reverb? Well, EnvironmentalReverb takes us to a whole new level where instead of presets, it provides us with the settings (in the form of properties) that are used to enable the Reverb effect on an audio piece. What effects, you ask? Here is a rundown of the audio effects that are collectively used to create\u00a0Reverb:</p>\n<h3>1. roomLevel:</h3>\n<ul>\n<li>Analogy: Think of this as adjusting the <em>background noise level</em> of the\u00a0room.</li>\n<li>Explanation: It\u2019s like the difference between performing in an empty quiet hall (low room level) versus a hall with some low-level chatter or ambient noise from the audience (high room level). It sets the general echo strength you get from the\u00a0room.</li>\n</ul>\n<h3>2. roomHFLevel:</h3>\n<ul>\n<li>Analogy: This is like deciding how much of the <em>high-pitched sounds</em> (like cymbals or a singer\u2019s \u201cS\u201d sounds) should bounce back to\u00a0you.</li>\n<li>Explanation: High frequencies are like those sharp notes that hit your ears directly. If you lower this, it feels like the walls are covered in soft material (like curtains), dampening the sharp, high-pitched sounds. If it\u2019s higher, it\u2019s like the walls are made of metal or glass, bouncing those sharp sounds back to\u00a0you.</li>\n</ul>\n<h3>3. decayTime:</h3>\n<ul>\n<li>Analogy: Imagine you clap your hands in a large cave. The time it takes for the echo to <em>die down</em> is the decay\u00a0time.</li>\n<li>Explanation: It\u2019s like choosing how long you want the echo to last. A short decay is like a small room where the echo fades quickly, while a long decay is like shouting in a vast cathedral where the sound lingers for a\u00a0while.</li>\n</ul>\n<h3>4. decayHFRatio:</h3>\n<ul>\n<li>Analogy: This is like deciding how quickly the <em>sharp notes</em> (like a whistle) fade away compared to the <em>deep bass notes</em> (like a drum\u00a0beat).</li>\n<li>Explanation: A higher ratio means the sharp, high-pitched echoes last longer, almost like a metallic ring. A lower ratio means the high-pitched sounds disappear quickly, like shouting into a\u00a0pillow.</li>\n</ul>\n<h3>5. reflectionsLevel:</h3>\n<ul>\n<li>Analogy: Imagine throwing a <em>bouncy ball</em> in a room. This setting is like deciding how <em>hard</em> you throw the ball at the walls, determining how much the first few bounces will be\u00a0heard.</li>\n<li>Explanation: It controls the initial loudness of the early reflections\u200a\u2014\u200athe first little echoes you hear right after the sound is made. If this is set low, it\u2019s like a gentle throw; if it\u2019s high, it\u2019s like a fast, hard throw that makes the bounces\u00a0louder.</li>\n</ul>\n<h3>6. reflectionsDelay:</h3>\n<ul>\n<li>Analogy: Think of it as the <em>time delay</em> before the first echo reaches your ears after you\u00a0shout.</li>\n<li>Explanation: It\u2019s like deciding how long it takes before you start hearing the first bounces of your voice. A short delay is like shouting in a small room (you hear it almost instantly), and a long delay is like yelling across a large field (the echo takes longer to\u00a0return).</li>\n</ul>\n<h3>7. reverbLevel:</h3>\n<ul>\n<li>Analogy: This is like deciding how much of a <em>concert hall effect</em> you want when you sing in your\u00a0shower.</li>\n<li>Explanation: It controls the overall loudness of the reverb (the trailing, spacious sound). Higher levels make it feel like you\u2019re performing in a huge concert hall (big, full reverb), while lower levels make it sound more like a small, cosy room (less\u00a0reverb).</li>\n</ul>\n<h3>8. reverbDelay:</h3>\n<ul>\n<li>Analogy: Picture an audience cheering after you hit a high note. This is like setting how long you wait before the <em>crowd\u2019s roar</em> reaches\u00a0you.</li>\n<li>Explanation: It\u2019s the delay before the main, louder part of the reverb starts. A longer delay feels like the sound is travelling from far away, and a shorter delay feels like it\u2019s bouncing back immediately.</li>\n</ul>\n<h3>9. diffusion:</h3>\n<ul>\n<li>Analogy: Imagine sprinkling coloured powder into the air and watching how it spreads. This setting is like deciding how <em>evenly the sound spreads</em> in the\u00a0room.</li>\n<li>Explanation: High diffusion means the echoes spread out more evenly and blend like the powder filling the whole room smoothly. Low diffusion is like clumps of powder\u200a\u2014\u200athe echoes are more distinct and separated.</li>\n</ul>\n<h3>10. density:</h3>\n<ul>\n<li>Analogy: Think of this as how <em>crowded</em> the sound echoes are in the room. It\u2019s like choosing between a sparsely populated party versus a packed dance\u00a0floor.</li>\n<li>Explanation: High density means the echoes are tightly packed together, creating a fuller and richer sound, like a busy party with people everywhere. The low density is like a sparse party where there are fewer echoes, and you can distinguish individual ones.</li>\n</ul>\n<p><strong>NB: </strong>I know that these are quite a lot and probably even a bit too technical to understand if you are not a music fiend. However, the good news is that these are only applicable if you are deep into Audio Processing and if you are not then you will of course be using PresetReverb\u00a0.</p>\n<p>That is enough theory. Now, let me show you how you use them in your Android\u00a0apps\u2026</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/220/0*cJmV0TjR6V1OqB62.gif\"></figure><p><strong>STEP 1: THE INSTANTIATION</strong></p>\n<p>As they are classes, you first need to instantiate them like regular Kotlin classes as\u00a0shown:</p>\n<pre>val presetReverb = PresetReverb()<br>val environmentalReverb = EnvironmentalReverb()<br></pre>\n<p><strong>STEP 2: THE MEDIA\u00a0PLAYER</strong></p>\n<p>Once you are done with the previous step, you will quickly realise that both classes have 2 parameters that need arguments which are priority and audioSession\u00a0. What are\u00a0they?</p>\n<h3>1. priority:</h3>\n<ul>\n<li>Analogy: Imagine you\u2019re at a crowded concert where everyone is trying to request songs from the DJ. The person who gets the DJ\u2019s attention first is the one with the highest priority.</li>\n<li>Explanation: In Android\u2019s audio effects system, multiple audio effects might compete for system resources or try to apply their changes to the audio stream at the same time. The priority parameter is used to determine which effect should get <em>preference</em> if there are limited resources. A higher priority value means the system will give more importance to that effect over others with lower priority.</li>\n<li>Example: If you have both EnvironmentalReverb and a PresetReverb running at the same time but with limited processing power, the one with the higher priority will be processed first or might be the only one applied if resources are\u00a0tight.</li>\n<li>Fun Analogy: Think of it as a VIP pass at a club. If you have a higher priority (VIP status), you get access before others. If you have lower priority, you might have to wait or even miss out if the club is\u00a0full!</li>\n</ul>\n<h3>2. audioSession:</h3>\n<ul>\n<li>Analogy: Imagine you are at a music festival with multiple stages. Each stage has its own unique vibe and sound setup. You want to make sure your reverb effect only applies to the music playing on one specific\u00a0stage.</li>\n<li>Explanation: The audioSession parameter specifies <em>which audio stream or session</em> the effect should be applied to. In Android, an audio session is like a <em>unique ID</em> for a particular audio stream (e.g., music player, video player, or game audio). By providing the audioSession ID, you tell the reverb effect to apply only to the audio coming from that specific session, rather than affecting all audio output on the\u00a0device.</li>\n<li>Example: If you set up an EnvironmentalReverb with an audio session ID of 123, it will only apply to the audio stream identified by 123. This is useful when you want specific effects for different audio sources, like applying a concert hall reverb to your music player while leaving a notification sound unaffected.</li>\n<li>Fun Analogy: It\u2019s like having a special remote control that only changes the volume of one particular TV in a room full of TVs. You don\u2019t want to change the volume on all TVs, just the one you are watching.</li>\n</ul>\n<p>Now that you understand what both of those parameters are, it is time to provide the arguments. For the priority parameter, it is entirely dependent on your preferences but be sure to use any valid Int value. As for the audioSession parameter, we are going to provide a Session Id. How do we do\u00a0that?</p>\n<p>To provide a Session ID, we first define a MediaPlayer instance. <strong>MediaPlayer</strong> is a class that is used for playing Audio and Video in Android. To learn more about it, check out this link: <a href=\"https://developer.android.com/media/platform/mediaplayer\">https://developer.android.com/media/platform/mediaplayer</a></p>\n<p>We can do this by instantiating it as\u00a0shown:</p>\n<pre>val mediaPlayer = MediaPlayer()</pre>\n<p>Now that we have a MediaPlayer instance, we can access our Session ID using its audioSessionId property as\u00a0shown:</p>\n<pre>val presetReverb = PresetReverb(0, mediaPlayer.audioSessionId)<br>val environmentalReverb = EnvironmentalReverb(0, mediaPlayer.audioSessionId)</pre>\n<h3>STEP 3: THE CUSTOMISATION</h3>\n<p>This is our final step so do not give up while you are still at it. The final part will now be customising our audio\u2019s Reverb depending on the class that we use. This is simple since all we need to do is use the apply {} block so that we can have direct access to the properties that represent the Reverb configurations. Based on our theory above, here is what the result will look\u00a0like:</p>\n<pre>val presetReverb = PresetReverb(0, mediaPlayer.audioSessionId).apply {<br>           enabled = true<br>           preset = PresetReverb.PRESET_LARGEHALL // You can use the others that I mentioned earlier...<br>}<br><br>val environmentalReverb = EnvironmentalReverb(0, mediaPlayer.audioSessionId).apply {<br>           enabled = true<br>           roomLevel = 0<br>           roomHFLevel = -4500<br>           decayTime = 10000<br>           decayHFRatio = 1000<br>           reflectionsLevel = -2000<br>           reflectionsDelay = 0<br>           reverbLevel = 0<br>           reverbDelay = 0<br>           diffusion = 1000<br>           density = 1000<br>}</pre>\n<p><strong>NB: </strong>In both classes, enabled is set to true to activate the Reverb audio effect. Otherwise, it will not be applied to the audio file. Also, the Reverb effect will be applied to the audio file since our MediaPlayer instance has been used to provide the Session ID of the\u00a0audio\u2026</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/220/0*npB4Xq7xNeZ-3Xy6.gif\"></figure><h3><strong>CONCLUSION</strong></h3>\n<p>In this article, we have gone through the steps needed to add the Reverb audio effect to our audio files in Android using PresetReverb and EnvironmentalReverb. By now, you should be able to bring life into your Android apps by applying (pun intended) both of those classes into your MediaPlayer instance to provide that Reverb effect that Music Producers swear by. Go forth, fellow Music Producers/Android Developers/Awesome Human Beings and reverberate your Android apps\u2026 (I am not sure if that was a good way to end this but I guess it will\u00a0do\u2026)</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/165/0*cdBTHPZbk9XIGBqp.gif\"></figure><p><strong>REFERENCES</strong></p>\n<p>Reverbs explained. (2023, June 27). <em>Reverbs explained!!</em> YouTube. <a href=\"https://youtu.be/97zH-_Rly7E?si=grJO9x_vDkhuAwiV\">https://youtu.be/97zH-_Rly7E?si=grJO9x_vDkhuAwiV</a></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=7907d0a98367\" width=\"1\" height=\"1\" alt=\"\">\n","content":"\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*7fLrxHQIHYavRtYqRiv4OQ.png\"></figure><p>If you are a sane human being, then you are a Music lover. Why would you not be when Music has everything to give and nothing to take away from you besides your stress and other ailments? Anyway, let us cut to the chase and figure out how Music intersects with Android. I am sure you are already thinking about Spotify, Soundcloud, Shazam, and all other Android apps that are centred around Music. However, what if I told you that what I am about to show you will give you more control over Music in your apps that transcends just playing the Music? Sounds good, right? (Pun totally intended\u2026) With that said, here is <strong>How To Add Reverb To Your Android\u00a0App:</strong></p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/498/0*azB5nHVfJjRLkp1k.gif\"></figure><h3>WHAT IS\u00a0REVERB?</h3>\n<p>If you are a fan of not just Music but Music Production, then you are likely to have been introduced and are well-acquainted with the word <strong>Reverb</strong>. You know that Music Producers always swear by using it in their work to make their art sound better in our ears, don\u2019t you? What is Reverb, though for those who may not be familiar with it? (I am sure you have heard its effect even if you may technically not know\u00a0it\u2026)</p>\n<p><strong>Reverb </strong>is an audio effect where sound is simulated to bounce off different kinds of surfaces which produces a special kind of echo that enriches that sound as perceived by the human\u00a0ear.</p>\n<p>This sounds technical but I can assure you that it is such a common phenomenon that you will be glad that you finally found a name for whatever effect you have been hearing in your favourite musical\u00a0pieces.</p>\n<p>Here is a quick video to demonstrate to you what Reverb sounds\u00a0like:</p>\n<a href=\"https://medium.com/media/4389c8818e8edcaba5b5e6c0618052ce/href\">https://medium.com/media/4389c8818e8edcaba5b5e6c0618052ce/href</a><p>As you have just seen (or watched/listened to be more specific), Reverb has different presets (this just means <strong>types</strong> or <strong>flavours</strong>) which can be used depending on what you want your audio to sound\u00a0like.</p>\n<h3>HOW DOES REVERB COME INTO\u00a0ANDROID?</h3>\n<p>Suppose you are building an Android app that plays audio and should allow its users to customise their audio files depending on their preferences (not SharedPreferences). You want to allow them to tweak different settings and audio effects, Reverb being one of them. How do you do this? Drum rolls,\u00a0please\u2026</p>\n<p><strong>EnvironmentalReverb </strong>and <strong>PresetReverb</strong>.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/220/0*4QnDoW8RkPc4pUHu.gif\"></figure><h3>WHAT IS \u201cENVIRONMENTALREVERB\u201d AND \u201cPRESETREVERB\u201d</h3>\n<p>These are both classes from the android.media.audiofx package and are used to customise the Reverb of your\u00a0audio.</p>\n<p>I already know that you are probably asking yourself why we have 2 classes and not just 1 so let me tell you\u00a0why:</p>\n<h3><strong>PresetReverb</strong></h3>\n<p>PresetReverb is a class that provides basic Reverb presets which are PRESET_LARGEHALL\u00a0, PRESET_LARGEROOM\u00a0, PRESET_MEDIUMHALL\u00a0, PRESET_MEDIUMROOM\u00a0, PRESET_SMALLROOM\u00a0, PRESET_PLATE\u00a0, and PRESET_NONE\u00a0. As you can already tell, it is easier for an Android Developer to quickly figure out which preset suits their Android apps just by their names. This means that PresetReverb is suited for adding basic Reverb to the audio files in your Android\u00a0app.</p>\n<h3>EnvironmentalReverb</h3>\n<p>EnvironmentalReverb on the other hand, is a class that provides more flexibility and customisation. How does it achieve this? Well, remember how PresetReverb simply had presets that could be used to enable a particular type of Reverb? Well, EnvironmentalReverb takes us to a whole new level where instead of presets, it provides us with the settings (in the form of properties) that are used to enable the Reverb effect on an audio piece. What effects, you ask? Here is a rundown of the audio effects that are collectively used to create\u00a0Reverb:</p>\n<h3>1. roomLevel:</h3>\n<ul>\n<li>Analogy: Think of this as adjusting the <em>background noise level</em> of the\u00a0room.</li>\n<li>Explanation: It\u2019s like the difference between performing in an empty quiet hall (low room level) versus a hall with some low-level chatter or ambient noise from the audience (high room level). It sets the general echo strength you get from the\u00a0room.</li>\n</ul>\n<h3>2. roomHFLevel:</h3>\n<ul>\n<li>Analogy: This is like deciding how much of the <em>high-pitched sounds</em> (like cymbals or a singer\u2019s \u201cS\u201d sounds) should bounce back to\u00a0you.</li>\n<li>Explanation: High frequencies are like those sharp notes that hit your ears directly. If you lower this, it feels like the walls are covered in soft material (like curtains), dampening the sharp, high-pitched sounds. If it\u2019s higher, it\u2019s like the walls are made of metal or glass, bouncing those sharp sounds back to\u00a0you.</li>\n</ul>\n<h3>3. decayTime:</h3>\n<ul>\n<li>Analogy: Imagine you clap your hands in a large cave. The time it takes for the echo to <em>die down</em> is the decay\u00a0time.</li>\n<li>Explanation: It\u2019s like choosing how long you want the echo to last. A short decay is like a small room where the echo fades quickly, while a long decay is like shouting in a vast cathedral where the sound lingers for a\u00a0while.</li>\n</ul>\n<h3>4. decayHFRatio:</h3>\n<ul>\n<li>Analogy: This is like deciding how quickly the <em>sharp notes</em> (like a whistle) fade away compared to the <em>deep bass notes</em> (like a drum\u00a0beat).</li>\n<li>Explanation: A higher ratio means the sharp, high-pitched echoes last longer, almost like a metallic ring. A lower ratio means the high-pitched sounds disappear quickly, like shouting into a\u00a0pillow.</li>\n</ul>\n<h3>5. reflectionsLevel:</h3>\n<ul>\n<li>Analogy: Imagine throwing a <em>bouncy ball</em> in a room. This setting is like deciding how <em>hard</em> you throw the ball at the walls, determining how much the first few bounces will be\u00a0heard.</li>\n<li>Explanation: It controls the initial loudness of the early reflections\u200a\u2014\u200athe first little echoes you hear right after the sound is made. If this is set low, it\u2019s like a gentle throw; if it\u2019s high, it\u2019s like a fast, hard throw that makes the bounces\u00a0louder.</li>\n</ul>\n<h3>6. reflectionsDelay:</h3>\n<ul>\n<li>Analogy: Think of it as the <em>time delay</em> before the first echo reaches your ears after you\u00a0shout.</li>\n<li>Explanation: It\u2019s like deciding how long it takes before you start hearing the first bounces of your voice. A short delay is like shouting in a small room (you hear it almost instantly), and a long delay is like yelling across a large field (the echo takes longer to\u00a0return).</li>\n</ul>\n<h3>7. reverbLevel:</h3>\n<ul>\n<li>Analogy: This is like deciding how much of a <em>concert hall effect</em> you want when you sing in your\u00a0shower.</li>\n<li>Explanation: It controls the overall loudness of the reverb (the trailing, spacious sound). Higher levels make it feel like you\u2019re performing in a huge concert hall (big, full reverb), while lower levels make it sound more like a small, cosy room (less\u00a0reverb).</li>\n</ul>\n<h3>8. reverbDelay:</h3>\n<ul>\n<li>Analogy: Picture an audience cheering after you hit a high note. This is like setting how long you wait before the <em>crowd\u2019s roar</em> reaches\u00a0you.</li>\n<li>Explanation: It\u2019s the delay before the main, louder part of the reverb starts. A longer delay feels like the sound is travelling from far away, and a shorter delay feels like it\u2019s bouncing back immediately.</li>\n</ul>\n<h3>9. diffusion:</h3>\n<ul>\n<li>Analogy: Imagine sprinkling coloured powder into the air and watching how it spreads. This setting is like deciding how <em>evenly the sound spreads</em> in the\u00a0room.</li>\n<li>Explanation: High diffusion means the echoes spread out more evenly and blend like the powder filling the whole room smoothly. Low diffusion is like clumps of powder\u200a\u2014\u200athe echoes are more distinct and separated.</li>\n</ul>\n<h3>10. density:</h3>\n<ul>\n<li>Analogy: Think of this as how <em>crowded</em> the sound echoes are in the room. It\u2019s like choosing between a sparsely populated party versus a packed dance\u00a0floor.</li>\n<li>Explanation: High density means the echoes are tightly packed together, creating a fuller and richer sound, like a busy party with people everywhere. The low density is like a sparse party where there are fewer echoes, and you can distinguish individual ones.</li>\n</ul>\n<p><strong>NB: </strong>I know that these are quite a lot and probably even a bit too technical to understand if you are not a music fiend. However, the good news is that these are only applicable if you are deep into Audio Processing and if you are not then you will of course be using PresetReverb\u00a0.</p>\n<p>That is enough theory. Now, let me show you how you use them in your Android\u00a0apps\u2026</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/220/0*cJmV0TjR6V1OqB62.gif\"></figure><p><strong>STEP 1: THE INSTANTIATION</strong></p>\n<p>As they are classes, you first need to instantiate them like regular Kotlin classes as\u00a0shown:</p>\n<pre>val presetReverb = PresetReverb()<br>val environmentalReverb = EnvironmentalReverb()<br></pre>\n<p><strong>STEP 2: THE MEDIA\u00a0PLAYER</strong></p>\n<p>Once you are done with the previous step, you will quickly realise that both classes have 2 parameters that need arguments which are priority and audioSession\u00a0. What are\u00a0they?</p>\n<h3>1. priority:</h3>\n<ul>\n<li>Analogy: Imagine you\u2019re at a crowded concert where everyone is trying to request songs from the DJ. The person who gets the DJ\u2019s attention first is the one with the highest priority.</li>\n<li>Explanation: In Android\u2019s audio effects system, multiple audio effects might compete for system resources or try to apply their changes to the audio stream at the same time. The priority parameter is used to determine which effect should get <em>preference</em> if there are limited resources. A higher priority value means the system will give more importance to that effect over others with lower priority.</li>\n<li>Example: If you have both EnvironmentalReverb and a PresetReverb running at the same time but with limited processing power, the one with the higher priority will be processed first or might be the only one applied if resources are\u00a0tight.</li>\n<li>Fun Analogy: Think of it as a VIP pass at a club. If you have a higher priority (VIP status), you get access before others. If you have lower priority, you might have to wait or even miss out if the club is\u00a0full!</li>\n</ul>\n<h3>2. audioSession:</h3>\n<ul>\n<li>Analogy: Imagine you are at a music festival with multiple stages. Each stage has its own unique vibe and sound setup. You want to make sure your reverb effect only applies to the music playing on one specific\u00a0stage.</li>\n<li>Explanation: The audioSession parameter specifies <em>which audio stream or session</em> the effect should be applied to. In Android, an audio session is like a <em>unique ID</em> for a particular audio stream (e.g., music player, video player, or game audio). By providing the audioSession ID, you tell the reverb effect to apply only to the audio coming from that specific session, rather than affecting all audio output on the\u00a0device.</li>\n<li>Example: If you set up an EnvironmentalReverb with an audio session ID of 123, it will only apply to the audio stream identified by 123. This is useful when you want specific effects for different audio sources, like applying a concert hall reverb to your music player while leaving a notification sound unaffected.</li>\n<li>Fun Analogy: It\u2019s like having a special remote control that only changes the volume of one particular TV in a room full of TVs. You don\u2019t want to change the volume on all TVs, just the one you are watching.</li>\n</ul>\n<p>Now that you understand what both of those parameters are, it is time to provide the arguments. For the priority parameter, it is entirely dependent on your preferences but be sure to use any valid Int value. As for the audioSession parameter, we are going to provide a Session Id. How do we do\u00a0that?</p>\n<p>To provide a Session ID, we first define a MediaPlayer instance. <strong>MediaPlayer</strong> is a class that is used for playing Audio and Video in Android. To learn more about it, check out this link: <a href=\"https://developer.android.com/media/platform/mediaplayer\">https://developer.android.com/media/platform/mediaplayer</a></p>\n<p>We can do this by instantiating it as\u00a0shown:</p>\n<pre>val mediaPlayer = MediaPlayer()</pre>\n<p>Now that we have a MediaPlayer instance, we can access our Session ID using its audioSessionId property as\u00a0shown:</p>\n<pre>val presetReverb = PresetReverb(0, mediaPlayer.audioSessionId)<br>val environmentalReverb = EnvironmentalReverb(0, mediaPlayer.audioSessionId)</pre>\n<h3>STEP 3: THE CUSTOMISATION</h3>\n<p>This is our final step so do not give up while you are still at it. The final part will now be customising our audio\u2019s Reverb depending on the class that we use. This is simple since all we need to do is use the apply {} block so that we can have direct access to the properties that represent the Reverb configurations. Based on our theory above, here is what the result will look\u00a0like:</p>\n<pre>val presetReverb = PresetReverb(0, mediaPlayer.audioSessionId).apply {<br>           enabled = true<br>           preset = PresetReverb.PRESET_LARGEHALL // You can use the others that I mentioned earlier...<br>}<br><br>val environmentalReverb = EnvironmentalReverb(0, mediaPlayer.audioSessionId).apply {<br>           enabled = true<br>           roomLevel = 0<br>           roomHFLevel = -4500<br>           decayTime = 10000<br>           decayHFRatio = 1000<br>           reflectionsLevel = -2000<br>           reflectionsDelay = 0<br>           reverbLevel = 0<br>           reverbDelay = 0<br>           diffusion = 1000<br>           density = 1000<br>}</pre>\n<p><strong>NB: </strong>In both classes, enabled is set to true to activate the Reverb audio effect. Otherwise, it will not be applied to the audio file. Also, the Reverb effect will be applied to the audio file since our MediaPlayer instance has been used to provide the Session ID of the\u00a0audio\u2026</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/220/0*npB4Xq7xNeZ-3Xy6.gif\"></figure><h3><strong>CONCLUSION</strong></h3>\n<p>In this article, we have gone through the steps needed to add the Reverb audio effect to our audio files in Android using PresetReverb and EnvironmentalReverb. By now, you should be able to bring life into your Android apps by applying (pun intended) both of those classes into your MediaPlayer instance to provide that Reverb effect that Music Producers swear by. Go forth, fellow Music Producers/Android Developers/Awesome Human Beings and reverberate your Android apps\u2026 (I am not sure if that was a good way to end this but I guess it will\u00a0do\u2026)</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/165/0*cdBTHPZbk9XIGBqp.gif\"></figure><p><strong>REFERENCES</strong></p>\n<p>Reverbs explained. (2023, June 27). <em>Reverbs explained!!</em> YouTube. <a href=\"https://youtu.be/97zH-_Rly7E?si=grJO9x_vDkhuAwiV\">https://youtu.be/97zH-_Rly7E?si=grJO9x_vDkhuAwiV</a></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=7907d0a98367\" width=\"1\" height=\"1\" alt=\"\">\n","enclosure":{},"categories":["androiddev","music-production","kotlin","android-app-development","jetpack-compose"]}]}